/********************* ROLES **********************/

CREATE ROLE FLOCATE_ALL;
CREATE ROLE FLOCATE_READ;
CREATE ROLE FLOCATE_WRITE;
/********************* UDFS ***********************/

/****************** GENERATORS ********************/

CREATE GENERATOR GEN_TBLUNIX_ID;
CREATE GENERATOR SEQ_CATALOGID;
CREATE GENERATOR SEQ_COMPUTERID;
CREATE GENERATOR SEQ_DATEID;
CREATE GENERATOR SEQ_EXEID;
CREATE GENERATOR SEQ_EXIFID;
CREATE GENERATOR SEQ_EXPOSUREPROGRAMID;
CREATE GENERATOR SEQ_FILEID;
CREATE GENERATOR SEQ_FILENAMEID;
CREATE GENERATOR SEQ_FLASHID;
CREATE GENERATOR SEQ_LIGHTSOURCEID;
CREATE GENERATOR SEQ_LOGSEQUENCE;
CREATE GENERATOR SEQ_MD5ID;
CREATE GENERATOR SEQ_MP3GENREID;
CREATE GENERATOR SEQ_MP3ID;
CREATE GENERATOR SEQ_ORIENTATIONID;
CREATE GENERATOR SEQ_PATHID;
CREATE GENERATOR SEQ_SCANID;
CREATE GENERATOR SEQ_USERCOMMENTID;
/******************** DOMAINS *********************/

CREATE DOMAIN MEMO
 AS BLOB SUB_TYPE 1
 DEFAULT NULL
 COLLATE UTF8;
/******************* PROCEDURES ******************/

SET TERM ^ ;
CREATE PROCEDURE CLEARALLDATA
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE CLEARLOGONEHOUR
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE SP_RECALC_INDEX_SELECTIVITY
AS
DECLARE VARIABLE S VARCHAR(200);
BEGIN
FOR select RDB$INDEX_NAME FROM RDB$INDICES INTO :S DO
BEGIN
S = 'SET statistics INDEX ' || s || ';';
EXECUTE STATEMENT :s;
END
SUSPEND;
END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE SPADDALLFILEDETAILS (
    CATALOGID INTEGER,
    COMPUTERNAME VARCHAR(255),
    DATEACCESSED TIMESTAMP,
    DATECREATED TIMESTAMP,
    DATEMODIFIED TIMESTAMP,
    EXECOMPANY VARCHAR(255),
    EXECOPYRIGHT VARCHAR(255),
    EXEDESCRIPTION VARCHAR(255),
    EXEFILEVERSION VARCHAR(255),
    EXEINTERNALNAME VARCHAR(255),
    EXEORIGINALFILENAME VARCHAR(255),
    EXEPRODUCTNAME VARCHAR(255),
    EXEPRODUCTVERSION VARCHAR(255),
    EXIFAPERTURE VARCHAR(255),
    EXIFARTIST VARCHAR(255),
    EXIFCOMPRESSEDBPP VARCHAR(255),
    EXIFCOPYRIGHT VARCHAR(255),
    EXIFDATETIME TIMESTAMP,
    EXIFDATETIMEDIGITIZED TIMESTAMP,
    EXIFDATETIMEORIGINAL TIMESTAMP,
    EXIFEXPOSURE VARCHAR(255),
    EXIFEXPOSUREPROGRAM VARCHAR(255),
    EXIFFLASH VARCHAR(255),
    EXIFFSTOPS VARCHAR(255),
    EXIFIMAGEDESCRIPTION VARCHAR(255),
    EXIFISO INTEGER,
    EXIFLIGHTSOURCE VARCHAR(255),
    EXIFMAKE VARCHAR(255),
    EXIFMAXAPERTURE VARCHAR(255),
    EXIFMETERINGMETHOD VARCHAR(255),
    EXIFMETERINGMODE VARCHAR(255),
    EXIFMODEL VARCHAR(255),
    EXIFORIENTATION VARCHAR(255),
    EXIFPIXELXDIMENSION INTEGER,
    EXIFPIXELYDIMENSION INTEGER,
    EXIFSHUTTERSPEED VARCHAR(255),
    EXIFSOFTWARE VARCHAR(255),
    EXIFUSERCOMMENTS VARCHAR(255),
    EXIFXRESOLUTION INTEGER,
    EXIFYRESOLUTION INTEGER,
    FILEDESCRIPTION VARCHAR(255),
    FILENAME VARCHAR(255),
    FILEPATH VARCHAR(255),
    FILESIZE BIGINT,
    FILETYPE VARCHAR(255),
    MD5HASH CHAR(32),
    MP3ALBUM VARCHAR(255),
    MP3ARTIST VARCHAR(255),
    MP3COMMENT VARCHAR(255),
    MP3GENRE VARCHAR(255),
    MP3TITLE VARCHAR(255),
    MP3TRACK SMALLINT,
    MP3YEAR INTEGER,
    UNIXUID INTEGER,
    UNIXGID INTEGER,
    UNIXMODE INTEGER,
    SCANID INTEGER )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

SET TERM ^ ;
CREATE PROCEDURE SPADDFILEDEFAULT (
    COMPUTERNAME VARCHAR(255),
    ROOT VARCHAR(255),
    DATEACCESSED TIMESTAMP,
    DATECREATED TIMESTAMP,
    DATEMODIFIED TIMESTAMP,
    EXECOMPANY VARCHAR(255),
    EXECOPYRIGHT VARCHAR(255),
    EXEDESCRIPTION VARCHAR(255),
    EXEFILEVERSION VARCHAR(255),
    EXEINTERNALNAME VARCHAR(255),
    EXEORIGINALFILENAME VARCHAR(255),
    EXEPRODUCTNAME VARCHAR(255),
    EXEPRODUCTVERSION VARCHAR(255),
    EXIFAPERTURE VARCHAR(255),
    EXIFARTIST VARCHAR(255),
    EXIFCOMPRESSEDBPP VARCHAR(255),
    EXIFCOPYRIGHT VARCHAR(255),
    EXIFDATETIME TIMESTAMP,
    EXIFDATETIMEDIGITIZED TIMESTAMP,
    EXIFDATETIMEORIGINAL TIMESTAMP,
    EXIFEXPOSURE VARCHAR(255),
    EXIFEXPOSUREPROGRAM VARCHAR(255),
    EXIFFLASH VARCHAR(255),
    EXIFFSTOPS VARCHAR(255),
    EXIFIMAGEDESCRIPTION VARCHAR(255),
    EXIFISO INTEGER,
    EXIFLIGHTSOURCE VARCHAR(255),
    EXIFMAKE VARCHAR(255),
    EXIFMAXAPERTURE VARCHAR(255),
    EXIFMETERINGMETHOD VARCHAR(255),
    EXIFMETERINGMODE VARCHAR(255),
    EXIFMODEL VARCHAR(255),
    EXIFORIENTATION VARCHAR(255),
    EXIFPIXELXDIMENSION INTEGER,
    EXIFPIXELYDIMENSION INTEGER,
    EXIFSHUTTERSPEED VARCHAR(255),
    EXIFSOFTWARE VARCHAR(255),
    EXIFUSERCOMMENTS VARCHAR(255),
    EXIFXRESOLUTION INTEGER,
    EXIFYRESOLUTION INTEGER,
    FILEDESCRIPTION VARCHAR(255),
    FILENAME VARCHAR(255),
    FILEPATH VARCHAR(255),
    FILESIZE BIGINT,
    FILETYPE VARCHAR(255),
    MD5HASH CHAR(32),
    MP3ALBUM VARCHAR(255),
    MP3ARTIST VARCHAR(255),
    MP3COMMENT VARCHAR(255),
    MP3GENRE VARCHAR(255),
    MP3TITLE VARCHAR(255),
    MP3TRACK SMALLINT,
    MP3YEAR INTEGER,
    UNIXUID INTEGER,
    UNIXGID INTEGER,
    UNIXMODE INTEGER )
AS
BEGIN SUSPEND; END^
SET TERM ; ^

/******************** TABLES **********************/

CREATE TABLE LOGS
(
  LOGSEQUENCE INTEGER NOT NULL,
  LOGDATE TIMESTAMP NOT NULL,
  LOGMESSAGE VARCHAR(2048),
  CONSTRAINT PK_LOGS PRIMARY KEY (LOGSEQUENCE)
);
CREATE TABLE TBLCATALOGS
(
  CATALOGID INTEGER NOT NULL,
  DESCRIPTION VARCHAR(255) NOT NULL,
  NOTES VARCHAR(5000),
  WHENCREATED TIMESTAMP,
  CONSTRAINT PK_TBLCATALOGS PRIMARY KEY (CATALOGID)
);
CREATE TABLE TBLCOMPUTERS
(
  COMPUTERID INTEGER NOT NULL,
  COMPUTERNAME VARCHAR(255) NOT NULL,
  CONSTRAINT PK_TBLCOMPUTERS PRIMARY KEY (COMPUTERID)
);
CREATE TABLE TBLEXES
(
  EXEID INTEGER NOT NULL,
  EXECOMPANY VARCHAR(255),
  EXECOPYRIGHT VARCHAR(255),
  EXEDESCRIPTION VARCHAR(255),
  EXEFILEVERSION VARCHAR(255),
  EXEINTERNALNAME VARCHAR(255),
  EXEORIGINALFILENAME VARCHAR(255),
  EXEPRODUCTNAME VARCHAR(255),
  EXEPRODUCTVERSION VARCHAR(255),
  CONSTRAINT PK_TBLEXES PRIMARY KEY (EXEID)
);
CREATE TABLE TBLEXIFS
(
  EXIFID INTEGER NOT NULL,
  EXIFAPERTURE VARCHAR(255),
  EXIFARTIST VARCHAR(255),
  EXIFCOMPRESSEDBPP VARCHAR(255),
  EXIFCOPYRIGHT VARCHAR(255),
  EXIFDATETIME TIMESTAMP,
  EXIFDATETIMEDIGITIZED TIMESTAMP,
  EXIFDATETIMEORIGINAL TIMESTAMP,
  EXIFEXPOSURE VARCHAR(255),
  EXIFEXPOSUREPROGRAM INTEGER,
  EXIFFLASH INTEGER,
  EXIFFSTOPS VARCHAR(255),
  EXIFIMAGEDESCRIPTION VARCHAR(255),
  EXIFISO INTEGER,
  EXIFLIGHTSOURCE INTEGER,
  EXIFMAKE VARCHAR(255),
  EXIFMAXAPERTURE VARCHAR(255),
  EXIFMETERINGMETHOD VARCHAR(255),
  EXIFMETERINGMODE VARCHAR(255),
  EXIFMODEL VARCHAR(255),
  EXIFORIENTATION INTEGER,
  EXIFPIXELXDIMENSION INTEGER,
  EXIFPIXELYDIMENSION INTEGER,
  EXIFSHUTTERSPEED VARCHAR(255),
  EXIFSOFTWARE VARCHAR(255),
  EXIFUSERCOMMENTS INTEGER,
  EXIFXRESOLUTION INTEGER,
  EXIFYRESOLUTION INTEGER,
  CONSTRAINT PK_TBLEXIFS PRIMARY KEY (EXIFID),
  CONSTRAINT UI_EXIF UNIQUE (EXIFDATETIME,EXIFDATETIMEDIGITIZED,EXIFDATETIMEORIGINAL,EXIFMODEL,EXIFUSERCOMMENTS)
);
CREATE TABLE TBLEXPOSUREPROGRAMS
(
  EXPOSUREPROGRAMID INTEGER NOT NULL,
  EXPOSUREPROGRAM VARCHAR(255),
  CONSTRAINT PK_TBLEXPOSUREPROGRAMS PRIMARY KEY (EXPOSUREPROGRAMID)
);
CREATE TABLE TBLFILENAMES
(
  FILENAMEID INTEGER NOT NULL,
  FILENAME VARCHAR(255) NOT NULL,
  CONSTRAINT PK_TBLFILENAMES PRIMARY KEY (FILENAMEID)
);
CREATE TABLE TBLFILES
(
  FILEID INTEGER NOT NULL,
  SCANID INTEGER,
  COMPUTERID INTEGER,
  UNIXID INTEGER,
  EXEID INTEGER,
  EXIFID INTEGER,
  FILENAMEID INTEGER NOT NULL,
  MD5ID INTEGER,
  MP3ID INTEGER,
  FILESIZE BIGINT,
  PATHID INTEGER NOT NULL,
  DATEMODIFIED TIMESTAMP,
  DATECREATED TIMESTAMP,
  DATEACCESSED TIMESTAMP,
  FILEDESCRIPTION VARCHAR(255),
  CONSTRAINT PK_TBLFILES PRIMARY KEY (FILEID)
);
CREATE TABLE TBLFLASHES
(
  FLASHID INTEGER NOT NULL,
  FLASH VARCHAR(255),
  CONSTRAINT PK_TBLFLASHES PRIMARY KEY (FLASHID)
);
CREATE TABLE TBLLIGHTSOURCES
(
  LIGHTSOURCEID INTEGER NOT NULL,
  LIGHTSOURCE VARCHAR(255),
  CONSTRAINT PK_TBLLIGHTSOURCES PRIMARY KEY (LIGHTSOURCEID)
);
CREATE TABLE TBLMD5S
(
  MD5ID INTEGER NOT NULL,
  MD5HASH CHAR(32),
  CONSTRAINT PK_TBLMD5S PRIMARY KEY (MD5ID)
);
CREATE TABLE TBLMP3GENRES
(
  MP3GENREID INTEGER NOT NULL,
  GENRE VARCHAR(255),
  CONSTRAINT PK_TBLMP3GENRES PRIMARY KEY (MP3GENREID)
);
CREATE TABLE TBLMP3S
(
  MP3ID INTEGER NOT NULL,
  MP3ALBUM VARCHAR(255),
  MP3ARTIST VARCHAR(255),
  MP3COMMENT VARCHAR(255),
  MP3TITLE VARCHAR(255),
  MP3TRACK INTEGER,
  MP3YEAR INTEGER,
  MP3GENREID INTEGER,
  CONSTRAINT PK_TBLMP3S PRIMARY KEY (MP3ID)
);
CREATE TABLE TBLORIENTATIONS
(
  ORIENTATIONID INTEGER NOT NULL,
  ORIENTATION VARCHAR(255),
  CONSTRAINT PK_TBLORIENTATIONS PRIMARY KEY (ORIENTATIONID)
);
CREATE TABLE TBLPATHS
(
  PATHID INTEGER NOT NULL,
  FILEPATH VARCHAR(255) NOT NULL,
  CONSTRAINT PK_TBLPATHS PRIMARY KEY (PATHID)
);
CREATE TABLE TBLSCANS
(
  SCANID INTEGER NOT NULL,
  CATALOGID INTEGER,
  ROOT VARCHAR(255) NOT NULL,
  VOLUME VARCHAR(255),
  SERIAL INTEGER,
  FILTERSTRING VARCHAR(50),
  DESCRIPTION VARCHAR(255) NOT NULL,
  WHENCREATED TIMESTAMP,
  CONSTRAINT PK_TBLSCANS PRIMARY KEY (SCANID),
  CONSTRAINT UI_TBLSCANS UNIQUE (CATALOGID,DESCRIPTION)	
);
CREATE TABLE TBLUNIX
(
  UNIXID INTEGER NOT NULL,
  UID INTEGER,
  GID INTEGER,
  MODE INTEGER,
  CONSTRAINT PK_TBLUNIX PRIMARY KEY (UNIXID),
  CONSTRAINT UNIQ_TBLUNIX_ALL UNIQUE (UID,GID,MODE)
);
CREATE TABLE TBLUSERCOMMENTS
(
  USERCOMMENTID INTEGER NOT NULL,
  "COMMENT" VARCHAR(255),
  USERCOMMENT VARCHAR(255),
  CONSTRAINT PK_TBLUSERCOMMENTS PRIMARY KEY (USERCOMMENTID)
);
/********************* VIEWS **********************/
CREATE VIEW SCANSPATHS (SCANID, PATHID)
AS      
/* write select statement here */
SELECT DISTINCT 
SCANID, PATHID
FROM
TBLFILES;

CREATE VIEW SCANFILES (SCANID, CATALOGID, ROOT, VOLUME, SERIAL, FILTERSTRING, DESCRIPTION, WHENCREATED, FILEID, COMPUTERID, EXEID, EXIFID, FILENAMEID, MD5ID, MP3ID, FILESIZE, PATHID, DATEMODIFIED, DATECREATED, DATEACCESSED, FILEDESCRIPTION)
AS       
SELECT 
s.SCANID, s.CATALOGID, s.ROOT, s.VOLUME, s.SERIAL, s.FILTERSTRING, s.DESCRIPTION, s.WHENCREATED,
a.FILEID, a.COMPUTERID, a.EXEID, a.EXIFID, a.FILENAMEID, a.MD5ID, a.MP3ID, a.FILESIZE, a.PATHID, a.DATEMODIFIED, a.DATECREATED, a.DATEACCESSED, a.FILEDESCRIPTION
	    FROM TBLFILES a INNER JOIN TBLSCANS s ON a.SCANID=s.SCANID;

UPDATE RDB$RELATIONS set RDB$DESCRIPTION = 'Join of TBLSCANS and TBLFILES. Useful for operations such as getting all subdirectories and sizes in a given scan/filesystem.
Bit strange why we have to give distinct. TODO: fix SQL; this must be easier to do.'
  where RDB$RELATION_NAME = 'SCANFILES';

CREATE VIEW SUBDIRECTORIES (SCANID, PATHID, FILEPATH, SUBDIR, SUBPATHID)
AS       
SELECT
DISTINCT 
S.SCANID,
P.PATHID, 
P.FILEPATH, 
C.FILEPATH AS SUBDIR, 
C.PATHID AS SUBPATHID
FROM 
(SCANSPATHS S INNER JOIN
TBLPATHS P ON S.PATHID=P.PATHID),
TBLPATHS C
WHERE C.FILEPATH LIKE P.FILEPATH || '%' 
ORDER BY P.FILEPATH, C.FILEPATH;
	
CREATE VIEW DIRECTORYSIZE (CATALOGID, SCANID, PATHID, FILEPATH, NONRECURSIVESIZE)
AS           
/* We can't use WITH CHECK OPTION because the aggregate will never allow this to be an updatable view */
SELECT SCANFILES.CATALOGID, SCANFILES.SCANID, 
TBLPATHS.PATHID,
TBLPATHS.FILEPATH, Sum(SCANFILES.FILESIZE) AS NONRECURSIVESIZE
FROM SCANFILES
INNER JOIN TBLPATHS 
ON SCANFILES.PATHID = TBLPATHS.PATHID
GROUP BY SCANFILES.CATALOGID, SCANFILES.SCANID, TBLPATHS.PATHID, TBLPATHS.FILEPATH;

CREATE VIEW CATALOGSCANS (CATALOGID, SCANID, CATALOGDESCRIPTION, CATALOGNOTES, CATALOGWHENCREATED, SCANROOT, SCANVOLUME, SCANSERIAL, SCANDESCRIPTION, SCANFILTERSTRING, SCANWHENCREATED)
AS       
SELECT 
C.CATALOGID,
S.SCANID,
C.DESCRIPTION,
C.NOTES,
C.WHENCREATED,
S.ROOT,
S.VOLUME,
S.SERIAL,
S.DESCRIPTION,
S.FILTERSTRING,
S.WHENCREATED
FROM 
TBLCATALOGS C INNER JOIN TBLSCANS S ON C.CATALOGID=S.CATALOGID
ORDER BY C.DESCRIPTION, S.ROOT
;
CREATE VIEW CUMULATIVEDIRECTORYSIZE (CATALOG_ID, SCAN_ID, FILEPATH, TOTALSIZE)
AS       
SELECT 
D.CATALOGID,
D.SCANID,
D.FILEPATH,
D.NONRECURSIVESIZE
FROM DIRECTORYSIZE D 
INNER JOIN SUBDIRECTORIES S
ON D.PATHID=S.SUBPATHID ORDER BY D.CATALOGID, D.SCANID, D.FILEPATH;
CREATE VIEW FILESDEFAULTSCAN (COMPUTERNAME, FILEPATH, FILENAME, FILESIZE, FILEDESCRIPTION, DATEMODIFIED, DATEACCESSED, DATECREATED, MD5HASH)
AS          
SELECT
computer.COMPUTERNAME, 
path.FILEPATH,
filename.FILENAME,
f.FILESIZE, 
f.FILEDESCRIPTION,
f.DATEMODIFIED,
f.DATEACCESSED,
f.DATECREATED,
hash.MD5HASH
FROM 
((((((TBLFILES f INNER JOIN TBLCOMPUTERS computer ON f.computerid=computer.COMPUTERID) 
INNER JOIN TBLSCANS scan ON f.SCANID=scan.SCANID)
  INNER JOIN TBLCATALOGS cat ON scan.CATALOGID=cat.CATALOGID)
    INNER JOIN TBLFILENAMES filename ON f.FILENAMEID=filename.FILENAMEID)
      INNER JOIN TBLPATHS path ON f.PATHID=path.PATHID)
        LEFT OUTER JOIN TBLMD5S hash ON f.MD5ID=hash.MD5ID)
WHERE scan.DESCRIPTION='Default scan' AND cat.DESCRIPTION='Default catalog'
ORDER BY computer.COMPUTERNAME, path.FILEPATH, filename.FILENAME;
CREATE VIEW FILESALLSCANS (CATALOGID, SCANID, COMPUTERNAME, FILEPATH, FILENAME, FILESIZE, FILEDESCRIPTION, DATEMODIFIED, DATEACCESSED, DATECREATED, MD5HASH)

AS              
SELECT
cat.CATALOGID,
scan.SCANID,
computer.COMPUTERNAME, 
path.FILEPATH,
filename.FILENAME,
f.FILESIZE, 
f.FILEDESCRIPTION,
f.DATEMODIFIED,
f.DATEACCESSED,
f.DATECREATED,
hash.MD5HASH
FROM 
((((((TBLFILES f INNER JOIN TBLCOMPUTERS computer ON f.computerid=computer.COMPUTERID) 
  INNER JOIN TBLSCANS scan ON f.SCANID=scan.SCANID)
    INNER JOIN TBLCATALOGS cat ON scan.CATALOGID=cat.CATALOGID)
      INNER JOIN TBLFILENAMES filename ON f.FILENAMEID=filename.FILENAMEID)
        INNER JOIN TBLPATHS path ON f.PATHID=path.PATHID)
          LEFT OUTER JOIN TBLMD5S hash ON f.MD5ID=hash.MD5ID)
ORDER BY computer.COMPUTERNAME, path.FILEPATH, filename.FILENAME;
CREATE VIEW FILES_EXTENSIONS (FILENAMEID, FILENAME, EXTENSION)
AS 
SELECT r.FILENAMEID, r.FILENAME, iif(position('.' in reverse(r.filename))>0,right(r.filename,position('.' in reverse(r.filename))-1),'') as EXTENSION
FROM TBLFILENAMES r;
/******************* EXCEPTIONS *******************/

CREATE EXCEPTION SPCOULDNOTFINDCATALOGINFO
'Could not add records: unable to add catalog information to database';
CREATE EXCEPTION SPCOULDNOTFINDCOMPUTERINFO
'Could not add records: unable to add computer name to database';
CREATE EXCEPTION SPCOULDNOTFINDDATEINFO
'Could not add records: unable to add date/time value to database';
CREATE EXCEPTION SPCOULDNOTFINDEXIFINFO
'Could not add records: unable to add EXIF information to database';
CREATE EXCEPTION SPCOULDNOTFINDEXPOSUREINFO
'Could not add records: unable to add EXIF exposure information to database';
CREATE EXCEPTION SPCOULDNOTFINDFILENAMEINFO
'Could not add records: unable to add filename information to database';
CREATE EXCEPTION SPCOULDNOTFINDFLASHINFO
'Could not add records: unable to add EXIF flash information to database';
CREATE EXCEPTION SPCOULDNOTFINDLIGHTSOURCEINFO
'Could not add records: unable to add EXIF light source information to database';
CREATE EXCEPTION SPCOULDNOTFINDMD5INFO
'Could not add records: unable to add MD5 hash information to database';
CREATE EXCEPTION SPCOULDNOTFINDMP3GENREINFO
'Could not add records: unable to add MP3 genre information to database';
CREATE EXCEPTION SPCOULDNOTFINDMP3INFO
'Could not add records: unable to add MP3 information to database';
CREATE EXCEPTION SPCOULDNOTFINDORIENTATIONINFO
'Could not add records: unable to add EXIF orientation information to database';
CREATE EXCEPTION SPCOULDNOTFINDPATHINFO
'Could not add records: unable to add path information to database.';
CREATE EXCEPTION SPCOULDNOTFINDSCANINFO
'Could not add records: unable to add scan information to database';
CREATE EXCEPTION SPCOULDNOTFINDUNIXINFO
'Could not add records: unable to add unix information to database';
CREATE EXCEPTION SPCOULDNOTFINDUSERCOMMINFO
'Could not add records: unable to add user comments value to database';
CREATE EXCEPTION SPCOULDNOTFINDVERSIONINFO
'Could not add records: unable to add version information to database';
CREATE EXCEPTION SPNOCATALOGSPECIFIED
'Could not add records: no catalog ID specified.';
CREATE EXCEPTION SPNOSCANSPECIFIED
'Could not add records: no scan ID specified.';
/******************** TRIGGERS ********************/

SET TERM ^ ;
CREATE TRIGGER SEQ_LOGS FOR LOGS ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.LOGSEQUENCE IS NULL) OR (NEW.LOGSEQUENCE=0)) THEN 
  BEGIN
    NEW.LOGSEQUENCE = NEXT VALUE FOR SEQ_LOGSEQUENCE;
  END 
  -- New log date if not specified
  IF (NEW.LOGDATE IS NULL) THEN
  BEGIN
    NEW.LOGDATE = CURRENT_TIMESTAMP;
  END
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLCATALOGS FOR TBLCATALOGS ACTIVE
BEFORE INSERT POSITION 0
AS
declare variable localWHENCREATED TIMESTAMP; /* The value for WHENCREATED */
BEGIN
  localWHENCREATED = CURRENT_TIMESTAMP;
  /* Get generated primary key unless it is specified */
  IF ((NEW.CatalogID IS NULL) OR (NEW.CatalogID=0)) THEN 
  BEGIN
    NEW.CatalogID = NEXT VALUE FOR SEQ_CATALOGID;
  END --new catalogid
/* Insert current date/time unless it is specified */
  IF (NEW.WHENCREATED IS NULL) THEN
  BEGIN
    NEW.WHENCREATED = localWHENCREATED; 
  END
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLCOMPUTERS FOR TBLCOMPUTERS ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  IF ((NEW.ComputerID IS NULL) OR (NEW.ComputerID=0)) THEN 
  BEGIN
  NEW.ComputerID = NEXT VALUE FOR SEQ_COMPUTERID;
  END --new primary key
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLEXES FOR TBLEXES ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.EXEID IS NULL) OR (NEW.EXEID=0)) THEN 
  BEGIN
    NEW.EXEID = NEXT VALUE FOR SEQ_EXEID;
  END --new primary key  
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLEXIFS FOR TBLEXIFS ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.EXIFID IS NULL) OR (NEW.EXIFID=0)) THEN 
  BEGIN
    NEW.EXIFID = NEXT VALUE FOR SEQ_EXIFID;
  END --new primary key
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLEXPOSUREPROGRAMS FOR TBLEXPOSUREPROGRAMS ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.EXPOSUREPROGRAMID IS NULL) OR (NEW.EXPOSUREPROGRAMID=0)) THEN 
  BEGIN
    NEW.EXPOSUREPROGRAMID = NEXT VALUE FOR SEQ_EXPOSUREPROGRAMID;
  END --new primary key  
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLFILENAMES FOR TBLFILENAMES ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.FileNameID IS NULL) OR (NEW.FileNameID=0)) THEN 
  BEGIN
    NEW.FileNameID = NEXT VALUE FOR SEQ_FILENAMEID;
  END --new primary key
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLFILES FOR TBLFILES ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.FileID IS NULL) OR (NEW.FileID=0)) THEN 
  BEGIN
    NEW.FileID = NEXT VALUE FOR SEQ_FILEID;
  END --new primary key  
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLFLASHES FOR TBLFLASHES ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.FLASHID IS NULL) OR (NEW.FLASHID=0)) THEN 
  BEGIN
    NEW.FLASHID = NEXT VALUE FOR SEQ_FLASHID;
  END --new primary key    
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLLIGHTSOURCES FOR TBLLIGHTSOURCES ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.LIGHTSOURCEID IS NULL) OR (NEW.LIGHTSOURCEID=0)) THEN 
  BEGIN
    NEW.LIGHTSOURCEID = NEXT VALUE FOR SEQ_LIGHTSOURCEID;
  END --new primary key    
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLMD5S FOR TBLMD5S ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.MD5ID IS NULL) OR (NEW.MD5ID=0)) THEN 
  BEGIN
    NEW.MD5ID = NEXT VALUE FOR SEQ_MD5ID;
  END --new primary key    
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLMP3GENRES FOR TBLMP3GENRES ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.MP3GENREID IS NULL) OR (NEW.MP3GENREID=0)) THEN 
  BEGIN
    NEW.MP3GENREID = NEXT VALUE FOR SEQ_MP3GENREID;
  END --new primary key  
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLMP3S FOR TBLMP3S ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.MP3ID IS NULL) OR (NEW.MP3ID=0)) THEN 
  BEGIN
    NEW.MP3ID = NEXT VALUE FOR SEQ_MP3ID;
  END --new primary key
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLORIENTATIONS FOR TBLORIENTATIONS ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.ORIENTATIONID IS NULL) OR (NEW.ORIENTATIONID=0)) THEN 
  BEGIN
    NEW.ORIENTATIONID = NEXT VALUE FOR SEQ_ORIENTATIONID;
  END --new primary key  
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLPATHS FOR TBLPATHS ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.PathID IS NULL) OR (NEW.PathID=0)) THEN 
  BEGIN
    NEW.PathID = NEXT VALUE FOR SEQ_PATHID;
  END --new primary key
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLSCANS FOR TBLSCANS ACTIVE
BEFORE INSERT POSITION 0
AS
declare variable localWHENCREATED TIMESTAMP; /* The value for WHENCREATED */
BEGIN
  localWHENCREATED = CURRENT_TIMESTAMP;
    -- New generated primary key if not specified.
  IF ((NEW.ScanID IS NULL) OR (NEW.ScanID=0)) THEN 
  BEGIN
    NEW.ScanID = NEXT VALUE FOR SEQ_SCANID;
  END --new primary key    
/* Insert current date/time unless it is specified */
  IF (NEW.WHENCREATED IS NULL) THEN
  BEGIN
    NEW.WHENCREATED = localWHENCREATED;
  END -- Determine new.whencreated.  
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER SEQ_TBLUSERCOMMENTS FOR TBLUSERCOMMENTS ACTIVE
BEFORE INSERT POSITION 0
AS
BEGIN
  -- New generated primary key if not specified.
  IF ((NEW.USERCOMMENTID IS NULL) OR (NEW.USERCOMMENTID=0)) THEN 
  BEGIN
    NEW.USERCOMMENTID = NEXT VALUE FOR SEQ_USERCOMMENTID;
  END --new primary key  
END^
SET TERM ; ^
SET TERM ^ ;
CREATE TRIGGER TBLUNIX_BI FOR TBLUNIX ACTIVE
BEFORE INSERT POSITION 0
AS
DECLARE VARIABLE tmp DECIMAL(18,0);
BEGIN
  IF (NEW.UNIXID IS NULL) THEN
    NEW.UNIXID = GEN_ID(GEN_TBLUNIX_ID, 1);
  ELSE
  BEGIN
    tmp = GEN_ID(GEN_TBLUNIX_ID, 0);
    if (tmp < new.UNIXID) then
      tmp = GEN_ID(GEN_TBLUNIX_ID, new.UNIXID-tmp);
  END
END^
SET TERM ; ^

UPDATE RDB$ROLES set
RDB$DESCRIPTION = 'Read, write and DDL/schema change rights on flocate data.
This user can directly access data in tables and change table and stored procedure definitions.'
where RDB$ROLE_NAME = 'FLOCATE_ALL';
UPDATE RDB$ROLES set
RDB$DESCRIPTION = 'Read-only access to flocate data; useful for e.g. auditors.'
where RDB$ROLE_NAME = 'FLOCATE_READ';
UPDATE RDB$ROLES set
RDB$DESCRIPTION = 'Read-write access to flocate data. No DDL/schema change rights or direct edit rights on tables (data entry goes via stored procedures).
Useful for utilities that add file scanning data.
'
where RDB$ROLE_NAME = 'FLOCATE_WRITE';
SET TERM ^ ;
ALTER PROCEDURE CLEARALLDATA
AS
BEGIN
  DELETE FROM LOGS;
  DELETE FROM TBLCATALOGS;
  
  DELETE FROM TBLSCANS;
  
  DELETE FROM TBLFILES;
  
  DELETE FROM TBLCOMPUTERS;
  DELETE FROM TBLEXES;
  DELETE FROM TBLEXIFS;
  DELETE FROM TBLFILENAMES;
  DELETE FROM TBLMD5S;
  DELETE FROM TBLMP3S;
  DELETE FROM TBLPATHS;
  
  DELETE FROM TBLEXPOSUREPROGRAMS;  
  DELETE FROM TBLFLASHES;
  DELETE FROM TBLLIGHTSOURCES;
  DELETE FROM TBLMP3GENRES;
  DELETE FROM TBLORIENTATIONS;  
  DELETE FROM TBLUSERCOMMENTS;
  
END^
SET TERM ; ^

UPDATE RDB$PROCEDURES set
  RDB$DESCRIPTION = 'Clears all data in database; handy for testing.'
  where RDB$PROCEDURE_NAME = 'CLEARALLDATA';

SET TERM ^ ;
ALTER PROCEDURE CLEARLOGONEHOUR
AS
BEGIN
  /* Remove all log entries older than an hour. */ 
  DELETE FROM LOGS WHERE LOGDATE < DATEADD(-1 HOUR TO CURRENT_TIMESTAMP);
END^
SET TERM ; ^

UPDATE RDB$PROCEDURES set
  RDB$DESCRIPTION = 'Removes log data older than an hour ago.
Handy for troubleshooting/cleaning up.'
  where RDB$PROCEDURE_NAME = 'CLEARLOGONEHOUR';

SET TERM ^ ;
ALTER PROCEDURE SPADDALLFILEDETAILS (
    CATALOGID INTEGER,
    COMPUTERNAME VARCHAR(255),
    DATEACCESSED TIMESTAMP,
    DATECREATED TIMESTAMP,
    DATEMODIFIED TIMESTAMP,
    EXECOMPANY VARCHAR(255),
    EXECOPYRIGHT VARCHAR(255),
    EXEDESCRIPTION VARCHAR(255),
    EXEFILEVERSION VARCHAR(255),
    EXEINTERNALNAME VARCHAR(255),
    EXEORIGINALFILENAME VARCHAR(255),
    EXEPRODUCTNAME VARCHAR(255),
    EXEPRODUCTVERSION VARCHAR(255),
    EXIFAPERTURE VARCHAR(255),
    EXIFARTIST VARCHAR(255),
    EXIFCOMPRESSEDBPP VARCHAR(255),
    EXIFCOPYRIGHT VARCHAR(255),
    EXIFDATETIME TIMESTAMP,
    EXIFDATETIMEDIGITIZED TIMESTAMP,
    EXIFDATETIMEORIGINAL TIMESTAMP,
    EXIFEXPOSURE VARCHAR(255),
    EXIFEXPOSUREPROGRAM VARCHAR(255),
    EXIFFLASH VARCHAR(255),
    EXIFFSTOPS VARCHAR(255),
    EXIFIMAGEDESCRIPTION VARCHAR(255),
    EXIFISO INTEGER,
    EXIFLIGHTSOURCE VARCHAR(255),
    EXIFMAKE VARCHAR(255),
    EXIFMAXAPERTURE VARCHAR(255),
    EXIFMETERINGMETHOD VARCHAR(255),
    EXIFMETERINGMODE VARCHAR(255),
    EXIFMODEL VARCHAR(255),
    EXIFORIENTATION VARCHAR(255),
    EXIFPIXELXDIMENSION INTEGER,
    EXIFPIXELYDIMENSION INTEGER,
    EXIFSHUTTERSPEED VARCHAR(255),
    EXIFSOFTWARE VARCHAR(255),
    EXIFUSERCOMMENTS VARCHAR(255),
    EXIFXRESOLUTION INTEGER,
    EXIFYRESOLUTION INTEGER,
    FILEDESCRIPTION VARCHAR(255),
    FILENAME VARCHAR(255),
    FILEPATH VARCHAR(255),
    FILESIZE BIGINT,
    FILETYPE VARCHAR(255),
    MD5HASH CHAR(32),
    MP3ALBUM VARCHAR(255),
    MP3ARTIST VARCHAR(255),
    MP3COMMENT VARCHAR(255),
    MP3GENRE VARCHAR(255),
    MP3TITLE VARCHAR(255),
    MP3TRACK SMALLINT,
    MP3YEAR INTEGER,
    UNIXUID INTEGER,
    UNIXGID INTEGER,
    UNIXMODE INTEGER,
    SCANID INTEGER )
AS
declare variable localCOMPUTERID INTEGER;
  declare variable localDUMMY INTEGER; --Dummy variable for stuff we want to forget about (eg. debug log calls)
  declare variable localEXEID INTEGER;
  declare variable localEXIFID INTEGER;
  declare variable localEXIFUSERCOMMENTSID INTEGER;
  declare variable localEXPOSUREPROGRAMID INTEGER;
  declare variable localFILENAMEID INTEGER;
  declare variable localFLASHID INTEGER;
  declare variable localLIGHTSOURCEID INTEGER;
  declare variable localMD5ID INTEGER;
  declare variable localMP3ID INTEGER;
  declare variable localMP3GENREID INTEGER;
  declare variable localORIENTATIONID INTEGER;
  declare variable localPATHID INTEGER;
  declare variable localUNIXID INTEGER;
begin
/*
Stored procedure that adds a file into the database,
as well as all related info such as path etc.
A program can call this stored procedure to add 
files without worrying about the table structure.
If you want to use a default catalog and scan, call
SPADDALLFILESDEFAULT instead.
Requires:
- catalog and scan for which file should be added
- path where file is found
- file name (without path) 
- file creation date/time
- file size in bytes
Optional:
- executable file info
- jpeg file info (exif tags)
- mp3 file info (id3 tags)
- *nix permissions/ownership info
- computer name/hostname where file found
- file description
Returns: nothing
*/


/*
We use autonomous transactions to write debugging info
to a log table. This requires Firebird 2.5+.
If you don't have that, modify the
IN AUTONOMOUS TRANSACTION blocks.                      

Debugging info is only persisted if the insert statements 
for the logs table are wrapped in these autonomous
transactions, so you can disable and enable logging
by setting/removing this.
Besides, the logging is only done on errors so performance impact
will be low anyway.
*/

/* 1. Test for required input */

IF (:CATALOGID IS NULL) THEN
BEGIN
    IN AUTONOMOUS TRANSACTION
    DO
    BEGIN
      INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPNOCATALOGSPECIFIED');
    END 
    EXCEPTION SPNOCATALOGSPECIFIED;
END

IF (:SCANID IS NULL) THEN
BEGIN
    IN AUTONOMOUS TRANSACTION
    DO
    BEGIN
      INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPNOSCANSPECIFIED');
    END 
    EXCEPTION SPNOSCANSPECIFIED;
END

/* 2. Test for valid input, initialize variables        */
/*
Also massages input: calls to this procedure might be done
from a language that doesn't properly support NULLs.
When we see obviously absurd values, we cast them as NULLS.
*/
/*
localDUMMY= TRIM('Starting initialization','/tmp/test.txt');
*/
localDUMMY=NULL;
localCOMPUTERID=NULL;
localEXEID=NULL;
localEXIFID=NULL;
localEXIFUSERCOMMENTSID=NULL;
localEXPOSUREPROGRAMID=NULL;
localFILENAMEID=NULL;
localFLASHID=NULL;
localLIGHTSOURCEID=NULL;
localMD5ID=NULL;
localMP3ID=NULL;
localMP3GENREID=NULL;
localORIENTATIONID=NULL;
localPATHID=NULL;
localUNIXID=NULL;

IF (TRIM(:COMPUTERNAME) = '') THEN
BEGIN
    COMPUTERNAME = NULL;
END

IF (:DATEACCESSED < '1600-01-01 00:00:00') THEN
/* 
This cannot possibly be a valid date time for a computer file,
photograph or recording.
*/
BEGIN
    DATEACCESSED=NULL;
END

IF (:DATECREATED < '1600-01-01 00:00:00') THEN
/* 
This cannot possibly be a valid date time for a computer file,
photograph or recording.
*/
BEGIN
    DATECREATED=NULL;
END

IF (:DATEMODIFIED < '1600-01-01 00:00:00') THEN
/* 
This cannot possibly be a valid date time for a computer file,
photograph or recording.
*/
BEGIN
    DATEMODIFIED=NULL;
END

IF (TRIM(:EXECOMPANY) = '') THEN
BEGIN
    EXECOMPANY = NULL;
END

IF (TRIM(:EXECOPYRIGHT) = '') THEN
BEGIN
    EXECOPYRIGHT = NULL;
END

IF (TRIM(:EXEDESCRIPTION) = '') THEN
BEGIN
    EXEDESCRIPTION = NULL;
END

IF (TRIM(:EXEFILEVERSION) = '') THEN
BEGIN
    EXEFILEVERSION = NULL;
END

IF (TRIM(:EXEINTERNALNAME) = '') THEN
BEGIN
    EXEINTERNALNAME = NULL;
END

IF (TRIM(:EXEORIGINALFILENAME) = '') THEN
BEGIN
    EXEORIGINALFILENAME = NULL;
END

IF (TRIM(:EXEPRODUCTNAME) = '') THEN
BEGIN
    EXEPRODUCTNAME = NULL;
END

IF (TRIM(:EXEPRODUCTVERSION) = '') THEN
BEGIN
    EXEPRODUCTVERSION = NULL;
END

IF (:EXIFDATETIME < '1600-01-01 00:00:00') THEN
/* 
This cannot possibly be a valid date time for a computer file,
photograph or recording.
*/
BEGIN
    EXIFDATETIME=NULL;
END

IF (:EXIFDATETIMEDIGITIZED < '1600-01-01 00:00:00') THEN
/* 
This cannot possibly be a valid date time for a computer file,
photograph or recording.
*/
BEGIN
    EXIFDATETIMEDIGITIZED=NULL;
END

IF (:EXIFDATETIMEORIGINAL < '1600-01-01 00:00:00') THEN
/* 
This cannot possibly be a valid date time for a computer file,
photograph or recording.
*/
BEGIN
    EXIFDATETIMEORIGINAL=NULL;
END

IF (TRIM(:EXIFEXPOSURE)='') THEN
BEGIN
    EXIFEXPOSURE=NULL;
END
IF (TRIM(:EXIFEXPOSUREPROGRAM)='') THEN
BEGIN
    EXIFEXPOSUREPROGRAM=NULL;
END

IF (TRIM(:EXIFFLASH)='') THEN
BEGIN
    EXIFFLASH=NULL;
END

IF (TRIM(:EXIFFSTOPS)='') THEN
BEGIN
    EXIFFSTOPS=NULL;
END

IF (TRIM(:EXIFIMAGEDESCRIPTION)='') THEN
BEGIN
    EXIFIMAGEDESCRIPTION=NULL;
END

IF (TRIM(:EXIFLIGHTSOURCE)='') THEN
BEGIN
    EXIFLIGHTSOURCE=NULL;
END

IF (TRIM(:EXIFMAKE)='') THEN
BEGIN
    EXIFMAKE=NULL;
END

IF (TRIM(:EXIFMAXAPERTURE)='') THEN
BEGIN
    EXIFMAXAPERTURE=NULL;
END

IF (TRIM(:EXIFMETERINGMETHOD)='') THEN
BEGIN
    EXIFMETERINGMETHOD=NULL;
END

IF (TRIM(:EXIFMETERINGMODE)='') THEN
BEGIN
    EXIFMETERINGMODE=NULL;
END

IF (TRIM(:EXIFMODEL)='') THEN
BEGIN
    EXIFMODEL=NULL;
END

IF (TRIM(:EXIFORIENTATION)='') THEN
BEGIN
    EXIFORIENTATION=NULL;
END

IF (TRIM(:EXIFSHUTTERSPEED)='') THEN
BEGIN
    EXIFSHUTTERSPEED=NULL;
END

IF (TRIM(:EXIFSOFTWARE)='') THEN
BEGIN
    EXIFSOFTWARE=NULL;
END

IF (TRIM(:EXIFUSERCOMMENTS)='') THEN
BEGIN
    EXIFUSERCOMMENTS=NULL;
END

IF (TRIM(:MD5HASH) = '') THEN
BEGIN
    MD5HASH = NULL;
END

IF (TRIM(:MP3ALBUM) = '') THEN
BEGIN
    MP3ALBUM = NULL;
END

IF (TRIM(:MP3ARTIST) = '') THEN
BEGIN
    MP3ARTIST = NULL;
END

IF (TRIM(:MP3COMMENT) = '') THEN
BEGIN
    MP3COMMENT = NULL;
END

IF (TRIM(:MP3GENRE) = '') THEN
BEGIN
    MP3GENRE = NULL;
END

IF (TRIM(:MP3TITLE) = '') THEN
BEGIN
    MP3TITLE = NULL;
END

IF (:MP3TRACK <= 0) THEN
BEGIN
    MP3TRACK = NULL;
END

IF (:MP3YEAR <= 1) THEN
BEGIN
    MP3YEAR = NULL;
END

/*
INSERT INTO LOGS (LOGMESSAGE) VALUES ('-- Initialization finished. Parameters:','/tmp/test.txt');
INSERT INTO LOGS (LOGMESSAGE) VALUES ('CATALOGID                      :*' || COALESCE (CATALOGID, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('COMPUTERNAME                   :*' || COALESCE (COMPUTERNAME, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('DATEACCESSED                   :*' || COALESCE (CAST(DATEACCESSED AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('DATECREATED                    :*' || COALESCE (CAST(DATECREATED AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('DATEMODIFIED                   :*' || COALESCE (CAST(DATEMODIFIED AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXECOMPANY                     :*' || COALESCE (EXECOMPANY, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXECOPYRIGHT                   :*' || COALESCE (EXECOPYRIGHT, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEDESCRIPTION                 :*' || COALESCE (EXEDESCRIPTION, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEFILEVERSION                 :*' || COALESCE (EXEFILEVERSION, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEINTERNALNAME                :*' || COALESCE (EXEINTERNALNAME, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEORIGINALFILENAME            :*' || COALESCE (EXEORIGINALFILENAME, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEPRODUCTNAME                 :*' || COALESCE (EXEPRODUCTNAME, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEPRODUCTVERSION              :*' || COALESCE (EXEPRODUCTVERSION, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFAPERTURE                   :*' || COALESCE (EXIFAPERTURE, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFARTIST                     :*' || COALESCE (EXIFARTIST, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFCOMPRESSEDBPP              :*' || COALESCE (EXIFCOMPRESSEDBPP, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFCOPYRIGHT                  :*' || COALESCE (EXIFCOPYRIGHT, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFDATETIME                   :*' || COALESCE (CAST(EXIFDATETIME AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFDATETIMEDIGITIZED          :*' || COALESCE (CAST(EXIFDATETIMEDIGITIZED AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFDATETIMEORIGINAL           :*' || COALESCE (CAST(EXIFDATETIMEORIGINAL AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFEXPOSURE                   :*' || COALESCE (EXIFEXPOSURE, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFEXPOSUREPROGRAM            :*' || COALESCE (EXIFEXPOSUREPROGRAM, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFFLASH                      :*' || COALESCE (EXIFFLASH, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFFSTOPS                     :*' || COALESCE (EXIFFSTOPS, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFIMAGEDESCRIPTION           :*' || COALESCE (EXIFIMAGEDESCRIPTION, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFISO                        :*' || COALESCE (CAST(EXIFISO AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFLIGHTSOURCE                :*' || COALESCE (EXIFLIGHTSOURCE, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFMAKE                       :*' || COALESCE (EXIFMAKE, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFMAXAPERTURE                :*' || COALESCE (EXIFMAXAPERTURE, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFMETERINGMETHOD             :*' || COALESCE (EXIFMETERINGMETHOD, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFMETERINGMODE               :*' || COALESCE (EXIFMETERINGMODE, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFMODEL                      :*' || COALESCE (EXIFMODEL, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFORIENTATION                :*' || COALESCE (EXIFORIENTATION, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFPIXELXDIMENSION            :*' || COALESCE (CAST(EXIFPIXELXDIMENSION AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFPIXELYDIMENSION            :*' || COALESCE (CAST(EXIFPIXELYDIMENSION AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFSHUTTERSPEED               :*' || COALESCE (EXIFSHUTTERSPEED, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFSOFTWARE                   :*' || COALESCE (EXIFSOFTWARE, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFUSERCOMMENTS               :*' || COALESCE (EXIFUSERCOMMENTS, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFXRESOLUTION                :*' || COALESCE (CAST(EXIFXRESOLUTION AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXIFYRESOLUTION                :*' || COALESCE (CAST(EXIFYRESOLUTION AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEDESCRIPTION                :*' || COALESCE (FILEDESCRIPTION, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (FILENAME, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (FILEPATH, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILESIZE                       :*' || COALESCE (CAST(FILESIZE AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILETYPE                       :*' || COALESCE (FILETYPE, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('MD5HASH                        :*' || COALESCE (MD5HASH, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3ALBUM                       :*' || COALESCE (MP3ALBUM, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3ARTIST                      :*' || COALESCE (MP3ARTIST, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3COMMENT                     :*' || COALESCE (MP3COMMENT, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3GENRE                       :*' || COALESCE (MP3GENRE, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3TITLE                       :*' || COALESCE (MP3TITLE, '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3TRACK                       :*' || COALESCE (CAST(MP3TRACK AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3YEAR                        :*' || COALESCE (CAST(MP3YEAR AS VARCHAR(40)), '<NULL>') || '*'); 
INSERT INTO LOGS (LOGMESSAGE) VALUES ('SCANID                         :*' || COALESCE (SCANID, '<NULL>') || '*');  
-- add unix stuff if you want to
*/

/* 1. Add path info if necessary                        */
SELECT PATHID FROM TBLPATHS WHERE FILEPATH=:filepath
    INTO :localPATHID;
IF (:localPATHID IS NULL) THEN
BEGIN
    /* Doesn't exist yet, so we have to add path data   */
    INSERT INTO TBLPATHS (FILEPATH) VALUES (:filepath) RETURNING PATHID INTO :localPATHID;
    IF (:localPATHID IS NULL) THEN
    BEGIN
    /* when we can't add the info                       */
    /* in the related table, we should just abort       */
      IN AUTONOMOUS TRANSACTION
      DO
      BEGIN    
        INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDPATHINFO'); 
        INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
        INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*'); 
        EXCEPTION SPCOULDNOTFINDPATHINFO;
      END
    END
END /*IF LOCALPATHID IS NULL THEN*/

/* 2. Add filename info if necessary                    */
SELECT FILENAMEID FROM TBLFILENAMES WHERE FILENAME=:filename
    INTO :localFILENAMEID;
IF (:localFILENAMEID IS NULL) THEN
BEGIN
    /* Doens't exist yet, so add filename data          */
    INSERT INTO TBLFILENAMES (FILENAME) VALUES (:filename) RETURNING FILENAMEID INTO :localFILENAMEID;
    IF (localFILENAMEID IS NULL) THEN
    BEGIN
    /* when we can't add the info                       */
    /* in the relatd table, we should just abort        */
      IN AUTONOMOUS TRANSACTION
      DO
      BEGIN        
        INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDFILENAMEINFO'); 
        INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
        INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*');
      END 
      EXCEPTION SPCOULDNOTFINDFILENAMEINFO;
    END
END /*IF localFILENAMEID IS NULL THEN*/

/* 3. Add computer name if necessary and present        */
/* check for empty values and don't add if computername */
/* is empty as it's a NOT NULL constraint               */
IF (:computername IS NOT NULL) THEN
BEGIN
    SELECT COMPUTERID FROM TBLCOMPUTERS WHERE COMPUTERNAME=:computername
        INTO :localCOMPUTERID;
    IF (:localCOMPUTERID IS NULL) THEN
    BEGIN
        /* Doens't exist yet, so add computer name          */
        INSERT INTO TBLCOMPUTERS (COMPUTERNAME) VALUES (:computername) RETURNING COMPUTERID INTO :localCOMPUTERID;
        IF (:localCOMPUTERID IS NULL) THEN
        BEGIN
            /* when we can't add the info                       */
            /* in the related table, we should just abort       */
            IN AUTONOMOUS TRANSACTION
            DO
            BEGIN            
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDCOMPUTERINFO'); 
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*'); 
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('COMPUTERNAME                   :*' || COALESCE (:COMPUTERNAME, '<NULL>') || '*');
            END            
            EXCEPTION SPCOULDNOTFINDCOMPUTERINFO;
        END
    END /*IF localFILENAMEID IS NULL THEN*/
END /*IF COMPUTERNAME IS NOT NULL THEN*/

/* 3.1 Add unix info if necessary present        */
/* check for empty values and don't add if  */
/* is null.           */
IF ((:unixuid IS NOT NULL) and (:unixgid IS NOT NULL) and (:unixmode IS NOT NULL)) THEN
BEGIN
    SELECT UNIXID FROM TBLUNIX WHERE 
      UID=:unixuid AND
      GID=:unixgid AND
      MODE=:unixmode
        INTO :localUNIXID;
    IF (:localUNIXID IS NULL) THEN
    BEGIN
        /* Doens't exist yet, so add */
        INSERT INTO TBLUNIX (UID,GID,MODE) VALUES (:unixuid,:unixgid,:unixmode) 
          RETURNING UNIXID INTO :localUNIXID;
        IF (:localUNIXID IS NULL) THEN
        BEGIN
            /* when we can't add the info                       */
            /* in the related table, we should just abort       */
            IN AUTONOMOUS TRANSACTION
            DO
            BEGIN            
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDUNIXINFO'); 
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*'); 
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('UNIXUID                        :*' || COALESCE (:UNIXUID, '<NULL>') || '*');
            END            
            EXCEPTION SPCOULDNOTFINDUNIXINFO;
        END
    END /*empty unix record*/
END /*valid unix record*/

/* 4. Add version info if present and necessary         */
/* We might add some records with empty fields, but that's ok */
BEGIN
    SELECT EXEID FROM TBLEXES WHERE 
        EXECOMPANY = :execompany AND
        EXECOPYRIGHT = :execopyright AND
        EXEDESCRIPTION = :exedescription AND
        EXEFILEVERSION = :exefileversion AND
        EXEINTERNALNAME = :exeinternalname AND
        EXEORIGINALFILENAME = :exeoriginalfilename AND
        EXEPRODUCTNAME = :exeproductname AND
        EXEPRODUCTVERSION = :exeproductversion
        INTO :localEXEID;    
    IF (:localEXEID IS NULL) THEN
    BEGIN
        /* Doesn't exist yet, so add version info - ONLY if we have valid data though */
        IF ((EXECOMPANY IS NOT NULL) or
            (EXECOPYRIGHT IS NOT NULL) or
            (EXEDESCRIPTION IS NOT NULL) or
            (EXEFILEVERSION IS NOT NULL) or
            (EXEINTERNALNAME IS NOT NULL) or
            (EXEORIGINALFILENAME IS NOT NULL) or
            (EXEPRODUCTNAME IS NOT NULL) or
            (EXEPRODUCTVERSION IS NOT NULL)) THEN
        BEGIN
			INSERT INTO TBLEXES (
				EXECOMPANY,
				EXECOPYRIGHT,
				EXEDESCRIPTION,
				EXEFILEVERSION,
				EXEINTERNALNAME,
				EXEORIGINALFILENAME,
				EXEPRODUCTNAME,
				EXEPRODUCTVERSION)  
				VALUES (
				:execompany,
				:execopyright,
				:exedescription,
				:exefileversion,
				:exeinternalname,
				:exeoriginalfilename,
				:exeproductname,
				:exeproductversion          
				) RETURNING EXEID INTO :localEXEID;
			IF (:localEXEID IS NULL) THEN
			BEGIN
				/* when we can't add the info                       */
				/* in the related table, we should just abort       */
				IN AUTONOMOUS TRANSACTION
				DO
				BEGIN            
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception for TBLEXES problems will be called: SPCOULDNOTFINDVERSIONINFO'); 
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*');             
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('localEXEID                     :*' || COALESCE (:localEXEID, '<NULL>') || '*');        
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXECOMPANY                     :*' || COALESCE (:EXECOMPANY, '<NULL>') || '*'); 
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXECOPYRIGHT                   :*' || COALESCE (:EXECOPYRIGHT, '<NULL>') || '*'); 
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEDESCRIPTION                 :*' || COALESCE (:EXEDESCRIPTION, '<NULL>') || '*'); 
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEFILEVERSION may not be NULL :*' || COALESCE (:EXEFILEVERSION, '<NULL>') || '*'); 
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEINTERNALNAME                :*' || COALESCE (:EXEINTERNALNAME, '<NULL>') || '*'); 
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEORIGINALFILENAME            :*' || COALESCE (:EXEORIGINALFILENAME, '<NULL>') || '*'); 
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEPRODUCTNAME                 :*' || COALESCE (:EXEPRODUCTNAME, '<NULL>') || '*'); 
				  INSERT INTO LOGS (LOGMESSAGE) VALUES ('EXEPRODUCTVERSION              :*' || COALESCE (:EXEPRODUCTVERSION, '<NULL>') || '*');
				END             
				EXCEPTION SPCOULDNOTFINDVERSIONINFO;
			END /* inner :localEXEID IS NULL) THEN */        
        END /* test for valid data */
    END /* outer :localEXEID IS NULL) THEN */
END

/* 5. Add file date info (modified, accessed, created) if present         */
/* obsolete */

/* 
6. Add MD5 info if present.
*/
IF (:MD5HASH IS NOT NULL) THEN
/* 
If MD5Hash is Null, we don't care as 
the localMD5ID has been initialized to NULL.
*/
BEGIN
    SELECT MD5ID FROM TBLMD5S WHERE MD5HASH=:MD5HASH
        INTO :localMD5ID;
    IF (:localMD5ID IS NULL) THEN
    BEGIN
        /* doesn't exist yet, so add date               */
        INSERT INTO TBLMD5S (
            MD5HASH
            )
            VALUES (
            :MD5HASH
            ) RETURNING MD5ID INTO :localMD5ID;
        IF (:localMD5ID IS NULL) THEN
        BEGIN
            /* when we can't add the info                       */
            /* in the related table, we should just abort       */
            IN AUTONOMOUS TRANSACTION
            DO
            BEGIN            
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDMD5INFO'); 
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*'); 
              INSERT INTO LOGS (LOGMESSAGE) VALUES ('MD5HASH                        :*' || COALESCE (:MD5HASH, '<NULL>') || '*');
            END
            EXCEPTION SPCOULDNOTFINDMD5INFO;        
        END
    END
END

/* 
7. Add mp3 info if present
*/
BEGIN
    /*
    First we need to get or add the genre, if specified at all.
    If not, the default NULL for localMP3GENREID will work for us.
    */
    IF ((:mp3genre IS NOT NULL) AND (:mp3genre <> '')) THEN
    BEGIN
        SELECT MP3GENREID FROM TBLMP3GENRES WHERE
            GENRE = :MP3GENRE
            INTO :localMP3GENREID;
        IF (:localMP3GENREID IS NULL) THEN
        BEGIN
            /* doesn't exist yet, so add               */
            INSERT INTO TBLMP3GENRES (
                GENRE
                )
                VALUES (
                :MP3GENRE
                ) RETURNING MP3GENREID INTO :localMP3GENREID;                  
            IF (:localMP3GENREID IS NULL) THEN
            BEGIN
                /* when we can't add the info                       */
                /* in the related table, we should just abort       */
                IN AUTONOMOUS TRANSACTION
                DO
                BEGIN
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDMP3GENREINFO'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3GENRE                       :*' || COALESCE (:MP3GENRE, '<NULL>') || '*');
                END /* autonomous transaction */
                EXCEPTION SPCOULDNOTFINDMP3GENREINFO;        
            END /*Inner :localMP3GENREID IS NULL*/
        END /*Outer :localMP3GENREID IS NULL*/
    END /* mp3genre empty test */
    
    /* 
    Now we can see whether an MP3 record already exists.
    Note that genre may be NULL, so we have to allow for that.
    */
    IF (:localMP3GENREID IS NULL) THEN
    BEGIN
        SELECT MP3ID FROM TBLMP3S WHERE
            MP3ALBUM = :MP3ALBUM AND
            MP3ARTIST = :MP3ARTIST AND
            MP3COMMENT = :MP3COMMENT AND
            MP3GENREID IS NULL AND
            MP3TITLE = :MP3TITLE AND
            MP3TRACK = :MP3TRACK AND
            MP3YEAR = :MP3YEAR
            INTO :localMP3ID;    
    END
    ELSE /* Valid genre */
    BEGIN
        SELECT MP3ID FROM TBLMP3S WHERE
            MP3ALBUM = :MP3ALBUM AND
            MP3ARTIST = :MP3ARTIST AND
            MP3COMMENT = :MP3COMMENT AND
            MP3GENREID = :localMP3GENREID AND
            MP3TITLE = :MP3TITLE AND
            MP3TRACK = :MP3TRACK AND
            MP3YEAR = :MP3YEAR
            INTO :localMP3ID;
    END
    IF (:localMP3ID IS NULL) THEN
    BEGIN
        /* doesn't exist yet, so add - only if we have valid data   */        
        IF ((MP3ALBUM IS NOT NULL) OR
            (MP3ARTIST IS NOT NULL) OR
            (MP3COMMENT IS NOT NULL) OR
            (MP3TITLE IS NOT NULL) OR
            (MP3TRACK IS NOT NULL) OR
            (MP3YEAR IS NOT NULL) OR
            (MP3GENRE IS NOT NULL)
            ) THEN
        BEGIN
			INSERT INTO TBLMP3S (
				MP3ALBUM,
				MP3ARTIST,
				MP3COMMENT,
				MP3GENREID,
				MP3TITLE,
				MP3TRACK,
				MP3YEAR
				)
				VALUES (
				:MP3ALBUM,
				:MP3ARTIST,
				:MP3COMMENT,
				:localMP3GENREID,
				:MP3TITLE,
				:MP3TRACK,
				:MP3YEAR
				) RETURNING MP3ID INTO :localMP3ID;        
			IF (:localMP3ID IS NULL) THEN
			BEGIN
				/* when we can't add the info                       */
				/* in the related table, we should just abort       */
				IN AUTONOMOUS TRANSACTION
				DO
				BEGIN
					INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDMP3INFO'); 
					INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
					INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*'); 
					INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3ALBUM                       :*' || COALESCE (:MP3ALBUM, '<NULL>') || '*'); 
					INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3ARTIST                      :*' || COALESCE (:MP3ARTIST, '<NULL>') || '*'); 
					INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3COMMENT                     :*' || COALESCE (:MP3COMMENT, '<NULL>') || '*'); 
					INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3GENRE                       :*' || COALESCE (:MP3GENRE, '<NULL>') || '*'); 
					INSERT INTO LOGS (LOGMESSAGE) VALUES ('localMP3GENREID                :*' || COALESCE (:localMP3GENREID, '<NULL>') || '*'); 
					INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3TITLE                       :*' || COALESCE (:MP3TITLE, '<NULL>') || '*'); 
					INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3TRACK                       :*' || COALESCE (CAST(:MP3TRACK AS VARCHAR(40)), '<NULL>') || '*'); 
					INSERT INTO LOGS (LOGMESSAGE) VALUES ('MP3YEAR                        :*' || COALESCE (CAST(:MP3YEAR AS VARCHAR(40)), '<NULL>') || '*'); 
				END /* autonomous transaction */
				EXCEPTION SPCOULDNOTFINDMP3INFO;        
			END /*Inner :localMP3ID IS NULL*/        
        END /* check for valid mp3 data */
    END /*Outer :localMP3ID IS NULL */
END

/*
8. Add EXIF info if present and necessary
Note: if exifdatetime and exifmodel are not null, we assume we've got a valid exif record.
*/

IF ((:EXIFDATETIME IS NOT NULL) AND (:EXIFMODEL IS NOT NULL)) THEN
/*
Possibly a valid exif record.
*/
BEGIN
/*
Look up and create usercomments if necessary 
*/
    IF (:EXIFUSERCOMMENTS IS NOT NULL) THEN
    BEGIN
        SELECT USERCOMMENTID FROM TBLUSERCOMMENTS WHERE USERCOMMENT=:EXIFUSERCOMMENTS 
            INTO :localEXIFUSERCOMMENTSID;
        IF (:localEXIFUSERCOMMENTSID IS NULL) THEN
        BEGIN
            /* Doesn't exist yet, so add */
            INSERT INTO TBLUSERCOMMENTS (
                USERCOMMENT
                )  
                VALUES (
                :EXIFUSERCOMMENTS
                ) RETURNING USERCOMMENTID INTO :localEXIFUSERCOMMENTSID;
            IF (:localEXIFUSERCOMMENTSID IS NULL) THEN
            BEGIN
                /* when we can't add the info                       */
                /* in the related table, we should just abort       */
                IN AUTONOMOUS TRANSACTION
                DO
                BEGIN
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDUSERCOMMINFO'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*'); 
                END
                EXCEPTION SPCOULDNOTFINDUSERCOMMINFO;
            END
        END /*IF localEXIFUSERCOMMENTSIDID IS NULL THEN*/
    END /*IF (:EXIFUSERCOMMENTS IS NOT NULL) THEN*/

/*
Use the unique index in TBLEXIFS to see if the record already exists.
We already know in this section that EXIFDATETIME and EXIFMODEL cannot be NULL as that was tested above.
Note, some values may be null. Use the new Firebird 2.5+ OR .. IS NULL for this.
*/
    SELECT EXIFID FROM TBLEXIFS WHERE
    EXIFDATETIME = :EXIFDATETIME
    AND (EXIFDATETIMEDIGITIZED = :EXIFDATETIMEDIGITIZED OR :EXIFDATETIMEDIGITIZED IS NULL)
    AND (EXIFDATETIMEORIGINAL = :EXIFDATETIMEORIGINAL OR :EXIFDATETIMEORIGINAL IS NULL)
    AND EXIFMODEL = :EXIFMODEL
    AND (EXIFUSERCOMMENTS = :localEXIFUSERCOMMENTSID OR :localEXIFUSERCOMMENTSID IS NULL)
    INTO :localEXIFID;
    
    IF (:localEXIFID IS NULL) THEN
/*
Doesn't exist; start adding the record.
*/
    BEGIN
        /*
        Add related tables if required:
        TBLEXPOSUREPROGRAMS
        TBLFLASHES
        TBLLIGHTSOURCES
        TBLORIENTATIONS
        */
        IF (:EXIFEXPOSUREPROGRAM IS NOT NULL) THEN
        BEGIN
            SELECT EXPOSUREPROGRAMID FROM TBLEXPOSUREPROGRAMS 
                WHERE EXPOSUREPROGRAM = :EXIFEXPOSUREPROGRAM
                INTO :localEXPOSUREPROGRAMID ;
            IF (:localEXPOSUREPROGRAMID IS NULL) THEN
            BEGIN
                /* Doens't exist yet, so we have to add  data   */
                INSERT INTO TBLEXPOSUREPROGRAMS (
                    EXPOSUREPROGRAM
                    )
                    VALUES (
                    :EXIFEXPOSUREPROGRAM
                    ) RETURNING EXPOSUREPROGRAMID INTO :localEXPOSUREPROGRAMID;
                IF (:localEXPOSUREPROGRAMID IS NULL) THEN
                BEGIN
                  /* when we can't add the info                       */
                  /* in the related table, we should just abort       */
                  IN AUTONOMOUS TRANSACTION
                  DO
                  BEGIN
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDEXPOSUREINFO'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*'); 
                  END
                  EXCEPTION SPCOULDNOTFINDEXPOSUREINFO;
                END /* Inner check */
            END /* Outer check */
        END /* User parameter was not null */

        IF (:EXIFFLASH IS NOT NULL) THEN
        BEGIN        
            SELECT FLASHID FROM TBLFLASHES 
                WHERE FLASH = :EXIFFLASH
                INTO :localFLASHID ;
            IF (:localFLASHID IS NULL) THEN
            BEGIN
                /* Doens't exist yet, so we have to add  data   */
                INSERT INTO TBLFLASHES (
                    FLASH)
                    VALUES (
                    :EXIFFLASH
                    ) RETURNING FLASHID INTO :localFLASHID;
                IF (:localFLASHID IS NULL) THEN
                BEGIN
                  /* when we can't add the info                       */
                  /* in the related table, we should just abort       */
                  IN AUTONOMOUS TRANSACTION
                  DO
                  BEGIN                  
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDFLASHINFO'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*'); 
                  END
                  EXCEPTION SPCOULDNOTFINDFLASHINFO;
                END /* Inner check */
            END /* Outer check */
        END /* User parameter was not null */
        
        IF (:EXIFLIGHTSOURCE IS NOT NULL) THEN
        BEGIN
            SELECT LIGHTSOURCEID FROM TBLLIGHTSOURCES 
                WHERE LIGHTSOURCE = :EXIFLIGHTSOURCE
                INTO :localLIGHTSOURCEID ;
            IF (:localLIGHTSOURCEID IS NULL) THEN
            BEGIN
                /* Doens't exist yet, so we have to add  data   */
                INSERT INTO TBLLIGHTSOURCES (
                    LIGHTSOURCE)
                    VALUES (
                    :EXIFLIGHTSOURCE
                    ) RETURNING LIGHTSOURCEID INTO :localLIGHTSOURCEID;
                IF (:localLIGHTSOURCEID IS NULL) THEN
                BEGIN
                  /* when we can't add the info                       */
                  /* in the related table, we should just abort       */
                  IN AUTONOMOUS TRANSACTION
                  DO
                  BEGIN
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDLIGHTSOURCEINFO'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*'); 
                  END /* Autonomous transaction */
                  EXCEPTION SPCOULDNOTFINDLIGHTSOURCEINFO;
                END /* Inner check */
            END /* Outer check */
        END /* User parameter was not null */ 
        
        IF (:EXIFORIENTATION IS NOT NULL) THEN
        BEGIN
            SELECT ORIENTATIONID FROM TBLORIENTATIONS 
                WHERE ORIENTATION = :EXIFORIENTATION
                INTO :localORIENTATIONID ;
            IF (:localORIENTATIONID IS NULL) THEN
            BEGIN
                /* Doens't exist yet, so we have to add  data   */
                INSERT INTO TBLORIENTATIONS (
                    ORIENTATION)
                    VALUES (
                    :EXIFORIENTATION
                    ) RETURNING ORIENTATIONID INTO :localORIENTATIONID;
                IF (:localORIENTATIONID IS NULL) THEN
                BEGIN
                  /* when we can't add the info                       */
                  /* in the related table, we should just abort       */
                  IN AUTONOMOUS TRANSACTION
                  DO
                  BEGIN
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDORIENTATIONINFO'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
                    INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*'); 
                  END /* autonomous transaction */
                  EXCEPTION SPCOULDNOTFINDORIENTATIONINFO;
                END /* Inner check */
            END /* Outer check */
        END /* User parameter was not null */
                   
        /* 
        Main EXIF table we can finally fill after
        having filled all foreign tables.
        */
        INSERT INTO TBLEXIFS (
            EXIFAPERTURE,
            EXIFARTIST ,
            EXIFCOMPRESSEDBPP ,
            EXIFCOPYRIGHT ,
            EXIFDATETIME ,
            EXIFDATETIMEDIGITIZED ,
            EXIFDATETIMEORIGINAL ,
            EXIFEXPOSURE ,
            EXIFEXPOSUREPROGRAM ,
            EXIFFLASH ,
            EXIFFSTOPS ,
            EXIFIMAGEDESCRIPTION ,
            EXIFISO ,
            EXIFLIGHTSOURCE ,
            EXIFMAKE ,
            EXIFMAXAPERTURE ,
            EXIFMETERINGMETHOD ,
            EXIFMETERINGMODE ,
            EXIFMODEL ,
            EXIFORIENTATION ,
            EXIFPIXELXDIMENSION ,
            EXIFPIXELYDIMENSION ,
            EXIFSHUTTERSPEED ,
            EXIFSOFTWARE ,
            EXIFUSERCOMMENTS ,
            EXIFXRESOLUTION ,
            EXIFYRESOLUTION)
        VALUES (
            :EXIFAPERTURE,
            :EXIFARTIST ,
            :EXIFCOMPRESSEDBPP ,
            :EXIFCOPYRIGHT ,
            :EXIFDATETIME ,
            :EXIFDATETIMEDIGITIZED ,
            :EXIFDATETIMEORIGINAL ,
            :EXIFEXPOSURE ,
            :localEXPOSUREPROGRAMID ,
            :localFLASHID ,
            :EXIFFSTOPS ,
            :EXIFIMAGEDESCRIPTION ,
            :EXIFISO ,
            :localLIGHTSOURCEID ,
            :EXIFMAKE ,
            :EXIFMAXAPERTURE ,
            :EXIFMETERINGMETHOD ,
            :EXIFMETERINGMODE ,
            :EXIFMODEL ,
            :localORIENTATIONID ,
            :EXIFPIXELXDIMENSION ,
            :EXIFPIXELYDIMENSION ,
            :EXIFSHUTTERSPEED ,
            :EXIFSOFTWARE ,
            :localEXIFUSERCOMMENTSID ,
            :EXIFXRESOLUTION ,
            :EXIFYRESOLUTION
            ) RETURNING EXIFID INTO :localEXIFID;
            
            /* Now see whether that worked */
        IF (:localEXIFID IS NULL) THEN
        BEGIN
            /* when we can't add the info                       */
            /* in the related table, we should just abort       */
            IN AUTONOMOUS TRANSACTION
            DO
            BEGIN
                INSERT INTO LOGS (LOGMESSAGE) VALUES ('Exception will be called: SPCOULDNOTFINDEXIFINFO'); 
                INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILENAME                       :*' || COALESCE (:FILENAME, '<NULL>') || '*'); 
                INSERT INTO LOGS (LOGMESSAGE) VALUES ('FILEPATH                       :*' || COALESCE (:FILEPATH, '<NULL>') || '*');             
            END /* autonomous transaction */
            EXCEPTION SPCOULDNOTFINDEXIFINFO;
        END
    END /*IF localEXIFID IS NULL THEN*/
END /*:EXIFDATETIME IS NOT NULL */

/* 999. Add file info, including all references */
INSERT INTO TBLFILES (     
    COMPUTERID,
    UNIXID,
    DATEACCESSED,
    DATECREATED,
    DATEMODIFIED, 
    EXEID,
    EXIFID, 
    FILEDESCRIPTION,
    FILENAMEID, 
    FILESIZE,     
    MD5ID,
    MP3ID,
    PATHID,
    SCANID) 
    VALUES 
    (
    :localCOMPUTERID,
    :localUNIXID,
    :DATEACCESSED,
    :DATECREATED,
    :DATEMODIFIED,
    :localEXEID,
    :localEXIFID,
    :FILEDESCRIPTION,
    :localFILENAMEID,
    :FILESIZE,
    :localMD5ID,
    :localMP3ID,
    :localPATHID,
    :SCANID
    );
end^
SET TERM ; ^


SET TERM ^ ;
ALTER PROCEDURE SPADDFILEDEFAULT (
    COMPUTERNAME VARCHAR(255),
    ROOT VARCHAR(255),
    DATEACCESSED TIMESTAMP,
    DATECREATED TIMESTAMP,
    DATEMODIFIED TIMESTAMP,
    EXECOMPANY VARCHAR(255),
    EXECOPYRIGHT VARCHAR(255),
    EXEDESCRIPTION VARCHAR(255),
    EXEFILEVERSION VARCHAR(255),
    EXEINTERNALNAME VARCHAR(255),
    EXEORIGINALFILENAME VARCHAR(255),
    EXEPRODUCTNAME VARCHAR(255),
    EXEPRODUCTVERSION VARCHAR(255),
    EXIFAPERTURE VARCHAR(255),
    EXIFARTIST VARCHAR(255),
    EXIFCOMPRESSEDBPP VARCHAR(255),
    EXIFCOPYRIGHT VARCHAR(255),
    EXIFDATETIME TIMESTAMP,
    EXIFDATETIMEDIGITIZED TIMESTAMP,
    EXIFDATETIMEORIGINAL TIMESTAMP,
    EXIFEXPOSURE VARCHAR(255),
    EXIFEXPOSUREPROGRAM VARCHAR(255),
    EXIFFLASH VARCHAR(255),
    EXIFFSTOPS VARCHAR(255),
    EXIFIMAGEDESCRIPTION VARCHAR(255),
    EXIFISO INTEGER,
    EXIFLIGHTSOURCE VARCHAR(255),
    EXIFMAKE VARCHAR(255),
    EXIFMAXAPERTURE VARCHAR(255),
    EXIFMETERINGMETHOD VARCHAR(255),
    EXIFMETERINGMODE VARCHAR(255),
    EXIFMODEL VARCHAR(255),
    EXIFORIENTATION VARCHAR(255),
    EXIFPIXELXDIMENSION INTEGER,
    EXIFPIXELYDIMENSION INTEGER,
    EXIFSHUTTERSPEED VARCHAR(255),
    EXIFSOFTWARE VARCHAR(255),
    EXIFUSERCOMMENTS VARCHAR(255),
    EXIFXRESOLUTION INTEGER,
    EXIFYRESOLUTION INTEGER,
    FILEDESCRIPTION VARCHAR(255),
    FILENAME VARCHAR(255),
    FILEPATH VARCHAR(255),
    FILESIZE BIGINT,
    FILETYPE VARCHAR(255),
    MD5HASH CHAR(32),
    MP3ALBUM VARCHAR(255),
    MP3ARTIST VARCHAR(255),
    MP3COMMENT VARCHAR(255),
    MP3GENRE VARCHAR(255),
    MP3TITLE VARCHAR(255),
    MP3TRACK SMALLINT,
    MP3YEAR INTEGER,
    UNIXUID INTEGER,
    UNIXGID INTEGER,
    UNIXMODE INTEGER )
AS
declare variable localCATALOGID Integer;
  declare variable localSCANID Integer;
  declare variable localCURRENTTIME Timestamp; /* Stores current time, now, at beginning of execution */
  declare variable localCURRENTTIMEID Integer; /* ID in date table that corresponds with now */
begin
/* Stored procedure that adds a file into the database, */
/* as well as all related info such as path etc.        */
/* A program can call this stored procedure to add      */
/* files without worrying about the table structure.    */
/* Creates/uses default catalog and scan. If you want   */
/* to specify them, use SPADDALLFILESDETAILS instead.   */
/* Requires: see SPADDALLFILEDETAILS                    */
/* Returns: nothing                                     */

/* 1. Get timestamp for both scan and catalog             */
localCURRENTTIME=CURRENT_TIMESTAMP;
 
/* 2. Test for catalog, add if necessary                */
SELECT CATALOGID FROM TBLCATALOGS WHERE DESCRIPTION='Default catalog'
    INTO :localCATALOGID;
IF (:localCATALOGID IS NULL) THEN
BEGIN
    /* doesn't exist yet, so we have to add path data   */
    INSERT INTO TBLCATALOGS (DESCRIPTION, NOTES, WHENCREATED) VALUES 
    ('Default catalog', 
    'System-generated catalog used for all scans that have no explicit catalog specified.',
    :localCURRENTTIME
    );
    SELECT CATALOGID FROM TBLCATALOGS WHERE DESCRIPTION='Default catalog'
        INTO :localCATALOGID;
    IF (:localCATALOGID IS NULL) THEN
    BEGIN
    /* when we can't add the info                       */
    /* in the related table, we should just abort       */
      EXCEPTION SPCOULDNOTFINDCATALOGINFO;
    END
END /*IF CCATALOGID IS NULL THEN*/

/* 2. Test for scan, add if necessary                */
/* NB: We can't use a date-derived numbering scheme to distinguish */
/* scans done at different times as we'll be receiving results one by one.*/
SELECT SCANID FROM TBLSCANS
    WHERE DESCRIPTION='Default scan'
    INTO :localSCANID;
IF (:localSCANID IS NULL) THEN
BEGIN
    /* doesn't exist yet, so we have to add path data   */
    INSERT INTO TBLSCANS 
    (CATALOGID, ROOT, DESCRIPTION, WHENCREATED) 
    VALUES (
    :localCATALOGID,
    :ROOT,
    'Default scan',
    :localCURRENTTIMEID
    );
    SELECT SCANID FROM TBLSCANS WHERE DESCRIPTION='Default scan'
        INTO :localSCANID;
    IF (:localSCANID IS NULL) THEN
    BEGIN
    /* when we can't add the info                       */
    /* in the related table, we should just abort       */
      EXCEPTION SPCOULDNOTFINDSCANINFO;
    END
END /*IF SCANID IS NULL THEN*/

EXECUTE PROCEDURE SPADDALLFILEDETAILS(
    :localCATALOGID,
    COMPUTERNAME,
    DATEACCESSED,
    DATECREATED ,
    DATEMODIFIED ,
    EXECOMPANY ,
    EXECOPYRIGHT ,
    EXEDESCRIPTION ,
    EXEFILEVERSION ,
    EXEINTERNALNAME,
    EXEORIGINALFILENAME ,
    EXEPRODUCTNAME ,
    EXEPRODUCTVERSION ,
    EXIFAPERTURE ,
    EXIFARTIST ,
    EXIFCOMPRESSEDBPP ,
    EXIFCOPYRIGHT ,
    EXIFDATETIME ,
    EXIFDATETIMEDIGITIZED ,
    EXIFDATETIMEORIGINAL ,
    EXIFEXPOSURE ,
    EXIFEXPOSUREPROGRAM , 
    EXIFFLASH ,
    EXIFFSTOPS, 
    EXIFIMAGEDESCRIPTION ,
    EXIFISO ,
    EXIFLIGHTSOURCE ,
    EXIFMAKE ,
    EXIFMAXAPERTURE,
    EXIFMETERINGMETHOD ,
    EXIFMETERINGMODE ,
    EXIFMODEL ,
    EXIFORIENTATION ,
    EXIFPIXELXDIMENSION ,
    EXIFPIXELYDIMENSION ,
    EXIFSHUTTERSPEED ,
    EXIFSOFTWARE ,
    EXIFUSERCOMMENTS ,
    EXIFXRESOLUTION ,
    EXIFYRESOLUTION ,
    FILEDESCRIPTION ,
    FILENAME ,
    FILEPATH ,
    FILESIZE ,
    FILETYPE ,
    MD5HASH ,
    MP3ALBUM ,
    MP3ARTIST ,
    MP3COMMENT ,
    MP3GENRE ,
    MP3TITLE ,
    MP3TRACK ,
    MP3YEAR,
    UNIXUID,
    UNIXGID,
    UNIXMODE,
    :localSCANID
);

/*
/* error handling for any error "when any"              */
/* we don't want to ignore errors, so I commented       */
/* this for now                                         */
/*WHEN ANY DO
BEGIN

END
*/
end^
SET TERM ; ^

UPDATE RDB$PROCEDURES set
  RDB$DESCRIPTION = 'Allows programs to add file information without specifying catalog or scan IDs.
Test:
EXECUTE PROCEDURE SPADDFILEDEFAULT(
    ''JEKYLL'' /*COMPUTERNAME*/,
    TIMESTAMP ''2009-07-31 14:04:22'', /* DATEACCESSED */
    TIMESTAMP ''1989-12-31 14:04:22'', /* DATECREATED */
    TIMESTAMP ''2005-02-03 09:22:12'', /* DATEMODIFIED */
    ''Microsoft'' /*EXECOMPANY*/,
    ''Copyright 1989'' /*EXECOPYRIGHT*/,
    ''MSDOS'' /*EXEDESCRIPTION*/,
    ''6.20'' /*EXEFILEVERSION*/,
    ''MS DOS 6.20'' /*EXEINTERNALNAME*/,
    ''AUTOEXEC.BAT'' /*EXEORIGINALFILENAME*/,
    ''MS DOS'' /*EXEPRODUCTNAME*/,
    ''6.20'' /*EXEPRODUCTVERSION*/,
    ''EXIFAPERTURE'' /*EXIFAPERTURE*/,
    ''Bill Gates'' /*EXIFARTIST*/,
    ''400bpp'' /*EXIFCOMPRESSEDBPP*/,
    ''Microsoft'' /*EXIFCOPYRIGHT*/,
    TIMESTAMP ''2009-07-31 14:04:22'', /* EXIFDATETIME */
    TIMESTAMP ''2009-07-31 14:04:22'', /* EXIFDATETIMEDIGITIZED */
    TIMESTAMP ''2005-02-03 09:22:12'', /* EXIFDATETIMEORIGINAL */
    ''Exposure is good!'' /*EXIFEXPOSURE*/,
    ''Systematic exposure program'' /*EXIFEXPOSUREPROGRAM*/,
    ''Flash Gordon'' /*EXIFFLASH*/,
    ''Pull out the stops'' /*EXIFFSTOPS*/,
    ''A picture of DOS in ASCII'' /*EXIFIMAGEDESCRIPTION*/,
    100 /*EXIFISO*/ ,
    ''Light from above'' /*EXIFLIGHTSOURCE*/,
    ''Canon'' /*EXIFMAKE*/,
    ''maxaperture'' /*EXIFMAXAPERTURE*/,
    ''metmethod'' /*EXIFMETERINGMETHOD*/,
    ''meteringmode'' /*EXIFMETERINGMODE*/,
    ''Ixus 300'' /*EXIFMODEL*/,
    ''Straight. or possibly bisexual'' /*EXIFORIENTATION*/,
    640 /*EXIFPIXELXDIMENSION*/ ,
    480 /*EXIFPIXELYDIMENSION*/ ,
    ''fast'' /*EXIFSHUTTERSPEED*/,
    ''Definitely software'' /*EXIFSOFTWARE*/,
    ''A picture of dos or something. Can be unicode'' /*EXIFUSERCOMMENTS*/,
    640 /*EXIFXRESOLUTION*/ ,
    480 /*EXIFYRESOLUTION*/ ,
    ''A description'' /*FILEDESCRIPTION*/,
    ''AUTOEXEC.BAT'' /*FILENAME*/,
    ''C:\'' /*FILEPATH*/,
    188 /*FILESIZE*/ ,
    ''Batch file'' /*FILETYPE*/,
    ''e4d909c290d0fb1ca068ffaddf22cbd0''/* MD5HASH */ ,
    ''Bill''''s greatest hits'' /*MP3ALBUM*/,
    ''B. Gates'' /*MP3ARTIST*/,
    ''Short names only'' /*MP3COMMENT*/,
    ''Antique'' /*MP3GENRE*/,
    ''Get this party started!'' /*MP3TITLE*/,
    6 /*MP3TRACK*/ ,
    1989 /*MP3YEAR*/
);      '
  where RDB$PROCEDURE_NAME = 'SPADDFILEDEFAULT';
UPDATE RDB$PROCEDURE_PARAMETERS set RDB$DESCRIPTION = 'Name of the computer running the scan'
  where RDB$PARAMETER_NAME = 'COMPUTERNAME' AND RDB$PROCEDURE_NAME = 'SPADDFILEDEFAULT';
UPDATE RDB$PROCEDURE_PARAMETERS set RDB$DESCRIPTION = 'Root directory that is the base of the scan'
  where RDB$PARAMETER_NAME = 'ROOT' AND RDB$PROCEDURE_NAME = 'SPADDFILEDEFAULT';

UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'User notes'  where RDB$FIELD_NAME = 'NOTES' and RDB$RELATION_NAME = 'TBLCATALOGS';
CREATE UNIQUE INDEX UICOMPUTERNAME ON TBLCOMPUTERS (COMPUTERNAME);
ALTER TABLE TBLEXES ADD CONSTRAINT CHK_TBLEXES_HASDATA
  check ((EXECOMPANY IS NOT NULL) or
(EXECOPYRIGHT IS NOT NULL) or
(EXEDESCRIPTION IS NOT NULL) or
(EXEFILEVERSION IS NOT NULL) or
(EXEINTERNALNAME IS NOT NULL) or
(EXEORIGINALFILENAME IS NOT NULL) or
(EXEPRODUCTNAME IS NOT NULL) or
(EXEPRODUCTVERSION IS NOT NULL));
ALTER TABLE TBLEXIFS ADD CONSTRAINT FK_EXIFEXPOSUREPROGRAM
  FOREIGN KEY (EXIFEXPOSUREPROGRAM) REFERENCES TBLEXPOSUREPROGRAMS (EXPOSUREPROGRAMID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLEXIFS ADD CONSTRAINT FK_EXIFFLASH
  FOREIGN KEY (EXIFFLASH) REFERENCES TBLFLASHES (FLASHID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLEXIFS ADD CONSTRAINT FK_EXIFLIGHTSOURCE
  FOREIGN KEY (EXIFLIGHTSOURCE) REFERENCES TBLLIGHTSOURCES (LIGHTSOURCEID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLEXIFS ADD CONSTRAINT FK_EXIFORIENTATION
  FOREIGN KEY (EXIFORIENTATION) REFERENCES TBLORIENTATIONS (ORIENTATIONID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLEXIFS ADD CONSTRAINT FK_EXIFUSERCOMMENTS
  FOREIGN KEY (EXIFUSERCOMMENTS) REFERENCES TBLUSERCOMMENTS (USERCOMMENTID) ON UPDATE CASCADE ON DELETE CASCADE;
CREATE UNIQUE INDEX UIFILENAME ON TBLFILENAMES (FILENAME);
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Link to Unix permissions/userID/groupID table'  where RDB$FIELD_NAME = 'UNIXID' and RDB$RELATION_NAME = 'TBLFILES';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'File size in bytes'  where RDB$FIELD_NAME = 'FILESIZE' and RDB$RELATION_NAME = 'TBLFILES';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Date when file was last modified.'  where RDB$FIELD_NAME = 'DATEMODIFIED' and RDB$RELATION_NAME = 'TBLFILES';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Date when file was initially created.'  where RDB$FIELD_NAME = 'DATECREATED' and RDB$RELATION_NAME = 'TBLFILES';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Date when file was last accessed/read/written.'  where RDB$FIELD_NAME = 'DATEACCESSED' and RDB$RELATION_NAME = 'TBLFILES';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'User-supplied description.'  where RDB$FIELD_NAME = 'FILEDESCRIPTION' and RDB$RELATION_NAME = 'TBLFILES';
ALTER TABLE TBLFILES ADD CONSTRAINT FK_COMPUTERID
  FOREIGN KEY (COMPUTERID) REFERENCES TBLCOMPUTERS (COMPUTERID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLFILES ADD CONSTRAINT FK_EXEID
  FOREIGN KEY (EXEID) REFERENCES TBLEXES (EXEID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLFILES ADD CONSTRAINT FK_EXIFID
  FOREIGN KEY (EXIFID) REFERENCES TBLEXIFS (EXIFID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLFILES ADD CONSTRAINT FK_FILENAMEID
  FOREIGN KEY (FILENAMEID) REFERENCES TBLFILENAMES (FILENAMEID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLFILES ADD CONSTRAINT FK_MD5ID
  FOREIGN KEY (MD5ID) REFERENCES TBLMD5S (MD5ID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLFILES ADD CONSTRAINT FK_MP3ID
  FOREIGN KEY (MP3ID) REFERENCES TBLMP3S (MP3ID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLFILES ADD CONSTRAINT FK_PATHID
  FOREIGN KEY (PATHID) REFERENCES TBLPATHS (PATHID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLFILES ADD CONSTRAINT FK_SCANID
  FOREIGN KEY (SCANID) REFERENCES TBLSCANS (SCANID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLFILES ADD CONSTRAINT FK_UNIXID
  FOREIGN KEY (UNIXID) REFERENCES TBLUNIX (UNIXID) ON UPDATE CASCADE ON DELETE CASCADE;
CREATE INDEX ICOMPUTERID ON TBLFILES (COMPUTERID);
CREATE INDEX IEXEID ON TBLFILES (EXEID);
CREATE INDEX IFILEDESCRIPTION ON TBLFILES (FILEDESCRIPTION);
CREATE INDEX IFILENAMEID ON TBLFILES (FILENAMEID);
CREATE INDEX IPATHID ON TBLFILES (PATHID);
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'The MD5 hash of the file contents.'  where RDB$FIELD_NAME = 'MD5HASH' and RDB$RELATION_NAME = 'TBLMD5S';
CREATE INDEX IMD5HASH ON TBLMD5S (MD5HASH);
ALTER TABLE TBLMP3S ADD CONSTRAINT FK_MP3GENREID
  FOREIGN KEY (MP3GENREID) REFERENCES TBLMP3GENRES (MP3GENREID) ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE TBLMP3S ADD CONSTRAINT CHK_TBLMP3S_HASDATA
  check ((MP3ALBUM IS NOT NULL) OR
(MP3ARTIST IS NOT NULL) OR
(MP3COMMENT IS NOT NULL) OR
(MP3TITLE IS NOT NULL) OR
(MP3TRACK IS NOT NULL) OR
(MP3YEAR IS NOT NULL) OR
(MP3GENREID IS NOT NULL));
CREATE UNIQUE INDEX UIFILEPATH ON TBLPATHS (FILEPATH);
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Unique identifier/primary key for scans.'  where RDB$FIELD_NAME = 'SCANID' and RDB$RELATION_NAME = 'TBLSCANS';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Link to catalog of which this scan is a part. A catalog may contain one or more scans.'  where RDB$FIELD_NAME = 'CATALOGID' and RDB$RELATION_NAME = 'TBLSCANS';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Path where the scan begins. Examples: C:\ on Windows, /usr on Unix/Linux/OSX'  where RDB$FIELD_NAME = 'ROOT' and RDB$RELATION_NAME = 'TBLSCANS';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Volume serial description for CD, DVD, Hard disk root. Handy for recognizing DVDs etc'  where RDB$FIELD_NAME = 'VOLUME' and RDB$RELATION_NAME = 'TBLSCANS';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Volume serial number (hopefully a unique id)'  where RDB$FIELD_NAME = 'SERIAL' and RDB$RELATION_NAME = 'TBLSCANS';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Filter used when scanning files. If not present, all files are scanned.'  where RDB$FIELD_NAME = 'FILTERSTRING' and RDB$RELATION_NAME = 'TBLSCANS';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Optional description of the scan: e.g. filesystem details.'  where RDB$FIELD_NAME = 'DESCRIPTION' and RDB$RELATION_NAME = 'TBLSCANS';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'System-generated: date when the scan record was created.'  where RDB$FIELD_NAME = 'WHENCREATED' and RDB$RELATION_NAME = 'TBLSCANS';
ALTER TABLE TBLSCANS ADD CONSTRAINT FK_CATALOGID
  FOREIGN KEY (CATALOGID) REFERENCES TBLCATALOGS (CATALOGID) ON UPDATE CASCADE ON DELETE CASCADE;
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'User ID, 4 bytes unsigned'  where RDB$FIELD_NAME = 'UID' and RDB$RELATION_NAME = 'TBLUNIX';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Group ID, 4 bytes unsigned'  where RDB$FIELD_NAME = 'GID' and RDB$RELATION_NAME = 'TBLUNIX';
UPDATE RDB$RELATION_FIELDS set RDB$DESCRIPTION = 'Mode/permissions (rwx), 4 bytes unsigned'  where RDB$FIELD_NAME = 'MODE' and RDB$RELATION_NAME = 'TBLUNIX';
UPDATE RDB$RELATIONS set
  RDB$DESCRIPTION = 'todo: work in progress; show directory and subdirectory size. should show size for entire c: or / drive....'
  where RDB$RELATION_NAME = 'CUMULATIVEDIRECTORYSIZE';
UPDATE RDB$RELATIONS set
  RDB$DESCRIPTION = 'Join of TBLSCANS and TBLFILES. Useful for operations such as getting all subdirectories and sizes in a given scan/filesystem.
Bit strange why we have to give distinct. TODO: fix SQL; this must be easier to do.'
  where RDB$RELATION_NAME = 'SCANFILES';
UPDATE RDB$RELATIONS set
  RDB$DESCRIPTION = 'All paths contained in all scans. Unique excerpt from TBLFILES. Useful for subdirectory calculation, etc.'
  where RDB$RELATION_NAME = 'SCANSPATHS';
UPDATE RDB$TRIGGERS set
  RDB$DESCRIPTION = 'Table for database/application level logging, e.g. for errors in stored procedures.'
  where RDB$TRIGGER_NAME = 'SEQ_LOGS';
GRANT EXECUTE
 ON PROCEDURE CLEARALLDATA TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE CLEARLOGONEHOUR TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE SPADDALLFILEDETAILS TO ROLE FLOCATE_ALL;

GRANT EXECUTE
 ON PROCEDURE SPADDALLFILEDETAILS TO ROLE FLOCATE_WRITE;

GRANT EXECUTE
 ON PROCEDURE SPADDALLFILEDETAILS TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE SPADDFILEDEFAULT TO ROLE FLOCATE_ALL;

GRANT EXECUTE
 ON PROCEDURE SPADDFILEDEFAULT TO ROLE FLOCATE_WRITE;

GRANT EXECUTE
 ON PROCEDURE SPADDFILEDEFAULT TO  SYSDBA;

GRANT EXECUTE
 ON PROCEDURE SP_RECALC_INDEX_SELECTIVITY TO  SYSDBA;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON LOGS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLCATALOGS TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLCATALOGS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLCOMPUTERS TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLCOMPUTERS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLEXES TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLEXES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLEXIFS TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLEXIFS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLEXPOSUREPROGRAMS TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLEXPOSUREPROGRAMS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLFILENAMES TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLFILENAMES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLFILES TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLFILES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLFLASHES TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLFLASHES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLLIGHTSOURCES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLMD5S TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLMD5S TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLMP3GENRES TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLMP3GENRES TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLMP3S TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLMP3S TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLORIENTATIONS TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLORIENTATIONS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLPATHS TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLPATHS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLSCANS TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLSCANS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLUNIX TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLUSERCOMMENTS TO ROLE FLOCATE_ALL;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON TBLUSERCOMMENTS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CATALOGSCANS TO  SYSDBA WITH GRANT OPTION;

GRANT SELECT
 ON CUMULATIVEDIRECTORYSIZE TO ROLE FLOCATE_ALL;

GRANT SELECT
 ON CUMULATIVEDIRECTORYSIZE TO ROLE FLOCATE_READ;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON CUMULATIVEDIRECTORYSIZE TO  SYSDBA WITH GRANT OPTION;

GRANT SELECT
 ON DIRECTORYSIZE TO ROLE FLOCATE_ALL;

GRANT SELECT
 ON DIRECTORYSIZE TO ROLE FLOCATE_READ;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON DIRECTORYSIZE TO  SYSDBA WITH GRANT OPTION;

GRANT SELECT
 ON FILESDEFAULTSCAN TO ROLE FLOCATE_ALL;

GRANT SELECT
 ON FILESDEFAULTSCAN TO ROLE FLOCATE_READ;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON FILESDEFAULTSCAN TO  SYSDBA WITH GRANT OPTION;
 
GRANT SELECT
 ON FILESALLSCANS TO ROLE FLOCATE_ALL;

GRANT SELECT
 ON FILESALLSCANS TO ROLE FLOCATE_READ;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON FILESALLSCANS TO  SYSDBA WITH GRANT OPTION;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON FILES_EXTENSIONS TO  SYSDBA WITH GRANT OPTION;

GRANT SELECT
 ON SCANFILES TO ROLE FLOCATE_ALL;

GRANT SELECT
 ON SCANFILES TO ROLE FLOCATE_READ;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON SCANFILES TO  SYSDBA WITH GRANT OPTION;

GRANT SELECT
 ON SCANSPATHS TO ROLE FLOCATE_ALL;

GRANT SELECT
 ON SCANSPATHS TO ROLE FLOCATE_READ;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON SCANSPATHS TO  SYSDBA WITH GRANT OPTION;

GRANT SELECT
 ON SUBDIRECTORIES TO ROLE FLOCATE_ALL;

GRANT SELECT
 ON SUBDIRECTORIES TO ROLE FLOCATE_READ;

GRANT DELETE, INSERT, REFERENCES, SELECT, UPDATE
 ON SUBDIRECTORIES TO  SYSDBA WITH GRANT OPTION;

