program pasql;

{Test program; lets you issue simple SQL queries against
Interbase/Firebird, MSSQL, MySQL, Oracle, PostgreSQL, SQLite, Sybase databases.

Defaults are set up for local MS SQL Server.

Requires database client libraries and... a database server...
or embedded library ;)

}

{$mode objfpc}{$H+}
{$APPTYPE CONSOLE}

uses {$IFDEF UNIX} {$IFDEF UseCThreads}
  cthreads, {$ENDIF} {$ENDIF} {$IFDEF WINDOWS}
  Windows {for environment vars}, {$ENDIF}
  Classes,
  SysUtils,
  CustApp,
  strutils,
  {$IF FPC_FULLVERSION>= 20601}  // This connector needs FPC 2.6.1 or higher...
  {$IFNDEF DARWIN}
  // For some reason, this connector isn't compiled on OSX.
  mssqlconn {MS SQL Server, Sybase ASE access},
  {$ENDIF} //darwin/osx
  {$ENDIF} //version
  {$IF FPC_FULLVERSION<20602}
  // Old FPC versions require explicit direction to use embedded library.
  // An empty hostname is not enough.
  ibase60dyn {for embedded firebird declaration},
  {$ENDIF}
  ibconnection {Firebird/Interbase access},
  mysql51conn {MySQL 5.1 client access },
  odbcconn {ODBC drivers},
  {$IFNDEF Win64}
  // Oracle not compiled at least for 64bit Windows.
  oracleconnection {Oracle access},
  {$ENDIF Win64}
  pqconnection {PostgreSQL access},
  sqlite3conn {sqlite3 access},
  sqldb,
  DB {for database errors};

type
  TDatabaseType = (dtFirebird, dtMSSQL, dtMySQL51, dtODBC, dtOracle, dtPostgreSQL, dtSQLite,
    dtSybase, dtUndefinedDatabaseType);
  TBooleanNull = (BFalse, BTrue, BNull); //False, true, undefined/unknown
  { TMyApplication }
  TMyApplication = class(TCustomApplication)
  private
    //Generic database connection; will use child methods/properties as needed.
    FConnection: TSQLConnection;
    //Database to connect to:
    FDatabase: string;
    FDatabaseType: TDatabaseType;
    FCharset: string;
    // Keeps log generated by SQLDB:
    FConnectionLog: TStringList;
    // user chose embedded (client/server) database:
    FEmbedded: TBooleanNull;
    //MS SQL Server: instance name to be used:
    FInstance: string;
    FQuery: TSQLQuery;
    //Port the server is listening on:
    FPort: integer;
    //Script that will be executed:
    FScriptFile: string;
    //Database host server name or IP address:
    FServer: string;
    FTransaction: TSQLTransaction;
    //Whether or not to use a trusted connection (i.e. operating system authetnication):
    //MS SQL Server: also known as SSPI
    FTrustedConnection: TBooleanNull;
    FUseInstance: TBooleanNull;
    //Username for database server:
    FUsername: string;
    //Password for database server:
    FPassword: string;
    //Contains original value of TDSVER environment variable:
    FOriginalTDSVER: string;
    //Whether we changed the environment variable:
    FWeChangedTDSVER: boolean;
    procedure CommandLineOptions;
    procedure Connect;
    procedure CreateDBFile;
    procedure Disconnect;
    function EncloseOption(Option: string): string;
    procedure GetUserInfo;
    procedure ProcessOptions;
    procedure RunScript;
    // Prints all field names in a table or error if table does not exist
    function PrintFields(Table: string): boolean;
    // Prints all tables
    function PrintTables: boolean;
    // Runs SQL and prints results to console
    function RunSQL(SQL: string; BriefOutput: boolean): boolean;
    // Shows console for user to interact with.
    procedure SQLConsole;
    procedure ShowCommandLineHelp;
    procedure ShowInfoAsOptions;
    procedure ShowUserInfo;
  protected
    procedure GetLogEvent(Sender: TSQLConnection; EventType: TDBEventType; const Msg: string);
    procedure DoRun; override;
  end;

  //implementation

const
  SybaseStatementSeparator = 'GO'; //Used in dtMSSQL, dtSybase consoles to run commands
  FirebirdStatementSeparator = 'COMMIT'; //Used in Firebird consoles to run commands

  procedure TMyApplication.ProcessOptions;
  // Sets options depending on selected database type etc.
  // E.g. Firebird does not support instances, so get rid of it
  // This will allow further code to be more simple
  begin
    case FDatabaseType of
      dtFirebird:
      begin
        // Doesn't support instances
        FUseInstance := BFalse;
        // todo: Does support trusted auth, but don't know if driver does
        // so disable it for now
        FTrustedConnection := BFalse;
      end;
      dtMSSQL:
      begin
        //No support for embedded:
        FEmbedded := BFalse;
      end;
      dtMySQL51:
      begin
        // nothing yet
      end;
      dtODBC:
      begin
        // Doesn't support instances
        FUseInstance := BFalse;
        // Does not support trusted connections:
        FTrustedConnection := BFalse;
      end;
      dtOracle:
      begin
        //No support for embedded:
        FEmbedded := BFalse;
        // Instances in the SQL Server/Sybase sense are not supported.
        // Specify instance in database name parameter, not separately
        FUseInstance := BFalse;
        // Does not support trusted connections:
        FTrustedConnection := BFalse;
      end;
      dtPostgreSQL:
      begin
        //No support for embedded:
        FEmbedded := BFalse;
        // Doesn't support instances
        FUseInstance := BFalse;
        // Does not support trusted connections:
        FTrustedConnection := BFalse;
      end;
      dtSQLite:
      begin
        FEmbedded := btrue;
        // Doesn't support instances
        FUseInstance := BFalse;
        // No idea if it requires a username/password.
        // Let's enable it.
        FTrustedConnection := BTrue;
      end;
      dtSybase:
      begin
        //No support for embedded:
        FEmbedded := BFalse;
        // Doesn't support instances
        FUseInstance := BFalse;
        // Might support trusted auth, but don't know if driver does
        // so disable it for now
        FTrustedConnection := BFalse;
      end;
      else
      begin
        // Do nothing, not even an exception, as the main logic needs to deal with this
      end;
    end;
  end;

  procedure TMyApplication.ShowCommandLineHelp;
  begin
    writeln('pasql is a small command processor for ');
    writeln('Firebird, Interbase, Microsoft SQL Server,');
    writeln('MySQL 5.1 client, ODBC, Oracle, ');
    writeln('PostgreSQL, SQLite and Sybase ASE databases.');
    writeln('');
    writeln('Please make sure you have the client libraries ');
    writeln('for your database server installed.');
    writeln('');
    writeln('Options:');
    writeln('-? or --help          show this help');
    writeln('-c <c>');
    writeln('--characterset=<c>    character set, default UTF-8');
    writeln('                      (utf8 for mysql)');
    writeln('-d or --database=<db> database name');
    writeln('                      or instance on Oracle');
    writeln('-e or --embedded      use file-based database if the server');
    writeln('                      supports it - e.g. sqlite, Firebird');
    writeln('-h <db>               database server IP address or name');
    writeln('--hostname=<host>     database server IP address or name');
    writeln('Apart from just specifying IP or name, you can also:');
    writeln('                      use <name>\<instance> (MS SQL Server)');
    writeln('                      use <name>:<port>');
    writeln('-p <passw>            password');
    writeln('--password=<passw>    password');
    writeln('--port=<port>         port number to connect to');
    writeln('-s                    trusted authentication (MS SQL Server only)');
    writeln('--trusted             trusted authentication (MS SQL Server only)');
    writeln('--script=<file>       run script with SQL commands after connection');
    writeln('-t <type>             type of server to connect to');
    writeln('--type=type           type of server to connect to');
    writeln('                      Database types:');
    writeln('                      FIREBIRD');
    writeln('                      ODBC');
    writeln('                      ORACLE');
    writeln('                      POSTGRESQL');
    writeln('                      SQLITE');
    writeln('                      SQLSERVER');
    writeln('                      SYBASE');
    writeln('-u <user>             username');
    writeln('--username=<user>     username');
  end;

  procedure TMyApplication.CommandLineOptions;
  var
    ErrorMessage: string;
    OptionValue: string;
    Position: integer;
  begin
    ErrorMessage := Self.CheckOptions('c:d:e?h:p:st:u:',
      'characterset: database: embedded help hostname: password: port: script: trusted type: username:');
    if Length(ErrorMessage) > 0 then
    begin
      writeln(ErrorMessage);
      ShowCommandLineHelp;
      halt(1); //Stop program with error code 1: incorrect command line options
    end;

    if (Self.HasOption('?', 'help')) or (Copy(Trim(ParamStr(1)), 1, 2) = '/?') then
    begin
      // Special handling for DOS users ;) who might
      // be familiar with the /? option
      ShowCommandLineHelp;
      halt(0); //Stop program, no errors.
    end;

    if Self.HasOption('c', 'characterset') then
    begin
      FCharset := Self.GetOptionValue('c', 'characterset');
    end;

    if Self.HasOption('d', 'database') then
    begin
      FDatabase := Self.GetOptionValue('d', 'database');
    end;

    if Self.HasOption('e', 'embedded') then
    begin
      FEmbedded := btrue;
      // Overrules hostname
      FServer := '';
    end;

    if Self.HasOption('h', 'hostname') then
    begin
      OptionValue := Self.GetOptionValue('h', 'hostname');
      FServer := OptionValue; //let's start here and adapt.
      Position := AnsiPos('\', OptionValue); //SQL Server syntax
      if Position > 0 then
      begin
        //FInstance specified
        FServer := copy(Optionvalue, 1, Position - 1);
        FInstance := ansimidstr(OptionValue, Position + 1, Length(OptionValue));
        FUseInstance := BTrue;
        OptionValue := '';
        //reset for next test; let FInstance overrule FPort in this option
      end;
      Position := AnsiPos(':', OptionValue);
      if Position > 0 then //FPort specified (SQL Server, probably others too)
      begin
        FServer := copy(Optionvalue, 1, Position - 1);
        FPort := StrToIntDef(ansimidstr(OptionValue, Position + 1, Length(OptionValue)), 0);
        OptionValue := ''; //reset for next test
      end;
    end;

    if Self.HasOption('trusted') then
      // before username, password, FDatabase type
    begin
      FTrustedConnection := BTrue;
    end;

    if Self.HasOption('u', 'username') then
    begin
      FUsername := Self.GetOptionValue('u', 'username');
      FTrustedConnection := BFalse; //Let username/password trump trusted auth
    end;

    if Self.HasOption('p', 'password') then
    begin
      FPassword := Self.GetOptionValue('p', 'password');
      FTrustedConnection := bfalse; //Let username/password trump trusted auth
    end;

    if Self.HasOption('port') then
    begin
      FPort := StrToIntDef(Self.GetOptionValue('port'), 0);
    end;

    if Self.HasOption('script') then
    begin
      FScriptFile := Self.GetOptionValue('script');
      if FileExists(FScriptFile) = false then
      begin
        writeln('Error: could not find script ' + FScriptFile + '. Ignoring script.');
        FScriptFile := '';
      end;
    end
    else
    begin
      FScriptFile := '';
    end;

    if Self.HasOption('t', 'type') then
      // Done after specifying FInstance, FServer etc. so we can check for it here
    begin
      OptionValue := UpperCase(Trim(Self.GetOptionValue('t', 'type')));
      case OptionValue of
        'FIREBIRD':
        begin
          FDatabaseType := dtFirebird;
          // dtFirebird does not support instances; FreeTDS doesn't support trusted auth.
          if FUseInstance = btrue then
            writeln('Error: Firebird does not support instances!');
          //todo: figure out how to handle trusted auth in dtFirebird
          // Can't really say anything about FEmbedded because FServer may be empty.
        end;
        'MYSQL', 'MYSQL51': //default mysql to only existing implementation right now
        begin
          FDatabaseType := dtMySQL51;
          // dtFirebird does not support instances; FreeTDS doesn't support trusted auth.
          if FUseInstance = btrue then
            writeln('Error: MySQL does not support instances!');
          if (Self.HasOption('d', 'database') = false) then
            FDatabase := 'mysql'; //should probably always be there
        end;
        'ODBC':
        begin
          FDatabaseType := dtODBC;
          if FUseInstance = btrue then
            writeln('Error: ODBC does not support instances!');
        end;
        'ORACLE':
        begin
          FDatabaseType := dtOracle;
          if FUseInstance = btrue then
            writeln('Error: please specify Oracle instance in database pareameter.');
        end;
        'POSTGRESQL':
        begin
          FDatabaseType := dtPostgreSQL;
          if (Self.HasOption('d', 'database') = false) then
            FDatabase := 'postgres';
          //should be there on 8.1+ postgres; otherwise use template1
          if FUseInstance = btrue then
            writeln('Error: PostgreSQL does not support instances!');
        end;
        'SQLSERVER':
        begin
          FDatabaseType := dtMSSQL;
          if (Self.HasOption('d', 'database') = false) then
            FDatabase := 'master'; //should always be there
        end;
        'SQLITE':
        begin
          FDatabaseType := dtSQLite;
          FEmbedded := btrue;
          FServer := '';
          if FUseInstance = btrue then
            writeln('Error: SQLite does not support instances!');
        end;
        'SYBASE':
        begin
          FDatabaseType := dtSybase;
          // dtSybase does not support instances; FreeTDS doesn't support trusted auth.
          if FUseInstance = btrue = true then
            writeln('Error: Sybase does not support instances!');
          if FTrustedConnection = btrue then
            writeln('Error: Sybase trusted auth not supported by this code. Please fix');
          if (Self.HasOption('d', 'database') = false) then
            FDatabase := 'master'; //should always be there
        end;
        else
        begin
          FDatabaseType := dtUndefinedDatabaseType; //MS SQL by default if something
          writeln('Unknown database type specified.');
          writeln('Stopping.');
          halt(2); //Exit code 2: no valid FDatabase type specified
        end;
      end;
    end
    else
    begin
      // No type specified as an option, but we can perhaps still deduce it.
      if (FTrustedConnection = BTrue) or (FUseInstance = BTrue) then
      begin
        // These options only pertain to dtMSSQL for now
        FDatabaseType := dtMSSQL;
      end
      else
      begin
        // Explicitly ask user.
        FDatabaseType := dtUndefinedDatabaseType;
      end;
    end;
  end;

  procedure TMyApplication.GetUserInfo;
  var
    Response: string;
    Position: integer;
    Scroll: integer;
  begin
    Self.ProcessOptions; //Get rid of invalid settings combinations
    // Check for defaults
    if ((FServer = '') and (Fembedded <> btrue)) or (FPort = 0) or (FUsername = '') or (FPassword = '') or
      (FDatabaseType = dtUndefinedDatabaseType) then
    begin
      writeln('pasql SQL interpreter');
      writeln('*********************');
      writeln('Please enter/confirm your connection settings.');
      writeln('Note: run pasql -h for details on command line options.');
      writeln('');
    end;

    if FDatabaseType = dtUndefinedDatabaseType then
    begin
      Response := '';
      writeln('Choose database type, one of:');
      writeln('FIREBIRD');
      writeln('MYSQL51'); //mysql 5.1 for now
      writeln('ODBC');
      writeln('ORACLE');
      writeln('POSTGRESQL');
      writeln('SQLITE');
      writeln('SQLSERVER');
      writeln('SYBASE');
      writeln('Please enter database type.');
      writeln('Enter nothing to keep current setting: FIREBIRD');
      readln(Response);
      Response := UpperCase(Trim(Response));
      case Response of
        'FIREBIRD', '':
        begin
          FDatabaseType := dtFirebird;
        end;
        'MYSQL','MYSQL51':
        begin
          FDatabaseType := dtMySQL51;
        end;
        'ODBC':
        begin
          FDatabaseType := dtODBC;
          FEmbedded := bFalse;
        end;
        'ORACLE':
        begin
          FDatabaseType := dtOracle;
          FEmbedded := bFalse;
        end;
        'POSTGRESQL':
        begin
          FDatabaseType := dtPostgreSQL;
          FEmbedded := bFalse;
        end;
        'SQLITE':
        begin
          FDatabaseType := dtSQLite;
          FEmbedded := btrue;
          FServer := '';
        end;
        'SQLSERVER':
        begin
          FDatabaseType := dtMSSQL; //Default
          FEmbedded := bFalse;
        end;
        'SYBASE':
        begin
          FDatabaseType := dtSybase;
          FEmbedded := bFalse;
        end
        else
        begin
          writeln('Unknown database type entered.');
          writeln('Program will now halt.');
          halt(2); //Exit code 2: no valid FDatabase type specified
        end;
      end;
      writeln('');
    end;

    if (FEmbedded <> btrue) and
      (FServer = '') and
      (FDatabaseType <> dtODBC) then
    begin
      Response := '';
      FServer := '';
      writeln('Enter server name/IP for database server.');
      writeln('Use server:port if you want to specify a port number as well.');
      if FDatabaseType = dtMSSQL then
      begin
        writeln('Use server\instance if you want to specify an instance.');
      end;
      if FDatabaseType = dtOracle then
      begin
        writeln('Do not enter instance information here.');
      end;
      if (FEmbedded=bFalse) then
        writeln('Enter nothing to keep current setting: 127.0.0.1')
      else
        writeln('Enter nothing if you are using an embedded/file-based database: ');
      readln(Response);
      // Default: no server if there's any chance we're using embedded
      if (FEmbedded=bFalse) and (trim(Response)='') then
        Response := '127.0.0.1';
      FServer := Response;
      Position := AnsiPos(':', Response);
      if Position > 0 then //FPort specified (SQL Server, probably others too)
      begin
        FServer := copy(Response, 1, Position - 1);
        FPort := StrToIntDef(ansimidstr(Response, Position + 1, Length(Response)), 0);
        Response := FServer; //reset for next test
      end;
      case FDatabasetype of
        dtFirebird:
        begin
          Position := AnsiPos('/', Response);
          if Position > 0 then //FPort number specified
          begin
            FServer := copy(Response, 1, Position - 1);
            FPort := StrToIntDef(ansimidstr(Response, Position + 1, Length(Response)), 0);
          end;
          if FServer = '' then
            FEmbedded := BTrue;
        end;
        dtMSSQL:
        begin
          Position := AnsiPos('\', Response);
          if Position > 0 then //FInstance specified
          begin
            FServer := copy(Response, 1, Position - 1);
            FInstance := ansimidstr(Response, Position + 1, Length(Response));
            FUseInstance := btrue;
            Response := FServer; //reset for next test
          end;
        end;
        dtMySQL51, dtODBC, dtOracle, dtPostgreSQL, dtSybase:
        begin
          FServer := Response;
        end;
        dtSQLite:
        begin
          if FServer <> '' then
          begin
            writeln('You may not specify a server name for SQLite. It will be ignored.');
            FServer := '';
          end;
        end
        else
          raise Exception.Create('Unknown database type, please fix this code');
      end;
      writeln('');
    end;

    if (FPort = 0)
      and (FUseInstance in [bFalse, bNull])
      and (FEmbedded <> bTrue)
      and (FDatabaseType <> dtODBC) then
    begin
      // Get FPort info
      Response := '';
      case FDatabaseType of
        dtFirebird: FPort := 3050;
        dtMSSQL: FPort := 1433;
        dtMySQL51: FPort := 3306;
        dtODBC: FPort := 50000; //unknown, set a random port - e.g. a DB2 one ;)
        dtOracle: FPort := 1521;
        dtPostgreSQL: FPort := 5432;
        dtSQLite: FPort := 0; //irrelevant
        dtSybase: FPort := 5000;
        else
          raise Exception.Create('Unknown database type, please fix this code');
      end;
      writeln('Enter port number where the server is listening on.');
      writeln('Enter nothing to keep current setting: ' + IntToStr(FPort));
      readln(Response);
      if Response <> '' then
      begin
        FPort := StrToInt(Response);
      end;
      writeln('');
    end;

    if FDatabase = '' then
    begin
      Response := '';
      case FDatabaseType of
        dtFirebird:
        begin
          // dtFirebird requires a FDatabase to connect to, it has
          // no sensible default.
          FDatabase := 'employee';
          writeln('Enter database name. ');
          writeln('(either the full path on the server or the alias defined on the server)');
          writeln('Enter nothing to keep current setting: ' + FDatabase);
          readln(Response);
          if Response <> '' then
          begin
            FDatabase := Response;
          end;
          writeln('');
        end;
        dtODBC:
        begin
          writeln('Enter DSN name - DSNless connections are not yet supported.');
          readln(Response);
          FDatabase := trim(Response);
          writeln('');
        end;
        dtOracle:
        begin
          // Oracle instance/SID is described as part of the database parameter.
          FDatabase := 'xe'; //default for Express Edition. Other common ones: orcl
          writeln('Enter database name/SID/instance ');
          writeln('Enter nothing to keep current setting: ' + FDatabase);
          readln(Response);
          if Response <> '' then
          begin
            FDatabase := Response;
          end;
          writeln('');
        end;
        dtMySQL51:
        begin
          FDatabase := 'mysql'; //sensible default, should always exist
        end;
        dtPostgreSQL:
        begin
          //IIRC, these dbs can/may live with an empty database; you get the default db
        end;
        dtSybase:
        begin
          FDatabase := 'master'; //sensible default, should always exist
        end;
        dtMSSQL:
        begin
          FDatabase := 'master'; //sensible default, should always exist
        end;
        dtSQLite:
        begin
          FDatabase := 'test.sqlite';
          writeln('Enter database name. ');
          writeln('Enter nothing to keep current setting: ' + FDatabase);
          readln(Response);
          if Response <> '' then
          begin
            FDatabase := Response;
          end;
          writeln('');
        end;
        else
          raise Exception.Create('Unknown database type, please fix this code');
      end;
    end;

    if (FDatabaseType = dtMSSQL) and
      (FUserName = '') and
      (FPassword = '') and
      (FTrustedConnection = BNull) then
    begin
      // User has not specified what authentication option to use.
      // Steer him towards trusted connction
      Response := '';
      writeln('Specify authentication method:');
      writeln('<T>rusted connection (integrated security)');
      writeln('<U>sername/password');
      writeln('Enter nothing to keep current setting: T');
      readln(Response);
      Response := UpperCase(Trim(Response));
      case Response of
        'U': FTrustedConnection := BFalse;
        'T', '': FTrustedConnection := BTrue; //default option
        else
        begin
          writeln('Unknown authentication method entered.');
          writeln('Program will now halt.');
          halt(3); //Exitcode 3: Unknown authentication method specified
        end;
      end;
      writeln('');
    end;

    if (FUsername = '') and
      (FTrustedConnection in [bFalse, BNull]) and
      (FDatabaseType <> dtSQLite) then
    begin
      Response := '';
      case FDatabaseType of
        dtFirebird:
          if (FEmbedded=bTrue) then
            FUserName := '' //don't hit security database on FB 2.5+; useful for Debian embedded
          else
            FUsername := 'SYSDBA';
        dtMSSQL, dtSybase: FUsername := 'sa';
        dtMySQL51: FUSerName := 'root';
        dtODBC: FUSerName := 'administrator';
        dtOracle: FUsername := 'SYSDBA';
        dtPostgreSQL: FUsername := 'postgres';
        dtSQLite: FUsername := '';
        else
          raise Exception.Create('Unknown database type, please fix this code');
      end;
      writeln('Enter username.');
      writeln('Enter nothing to keep current setting: ' + FUsername);
      readln(Response);
      if Response <> '' then
      begin
        FUsername := Response;
      end;
      writeln('');
    end;

    if (FPassword = '') and
      (FTrustedConnection in [BFalse, BNull]) and
      (FEmbedded in [BFalse, BNull]) then
    begin
      Response := '';
      writeln('Enter password ');
      case FDatabaseType of
        dtFirebird: writeln('(Default password: masterkey)');
        dtMSSQL, dtMySQL51, dtODBC, dtOracle, dtPostgreSQL, dtSQLite,
        dtSybase: writeln('(Default password: <blank>)');
      end;
      writeln('(NOTE: NOT HIDDEN ON SCREEN, WILL ALSO BE SHOWN LATER): ');
      readln(Response);
      if Response <> '' then
      begin
        FPassword := Response;
      end;
      writeln('');
    end;

    FOriginalTDSVER := GetEnvironmentVariable('TDSVER');
    if FDatabaseType in [dtMSSQL, dtSybase] then
    begin
      if FOriginalTDSVER <> '' then
      begin
        writeln('Note: TDSVER environment variable is set to: ' + FOriginalTDSVER);
        writeln('This might influence connectivity with the server.');
      end
      else
      begin
        if FDatabasetype = dtSybase then
        begin
          //workaround for older dblib.dlls that don't support setting TDSVER 5 for sybase
        {$IFDEF WINDOWS}
          SetEnvironmentVariable('TDSVER', '5.0');
          FWeChangedTDSVER := true;
        {$ENDIF WINDOWS}
        {$IFNDEF WINDOWS}
        {$IFDEF UNIX}
          writeln('Warning: no support for setting environment variables on this Unix/Linux system.');
          writeln('FreeTDS connection may fail.');
          FWeChangedTDSVER := false;
        {$ELSE}
          writeln('Warning: no support for setting environment variables on this system.');
          writeln('FreeTDS connection may fail.');
          FWeChangedTDSVER := false;
        {$ENDIF UNIX}
        {$ENDIF WINDOWS}
        end;
      end;
    end;

    //scroll some, the lazy way, so we hide some passwords ;)
    for Scroll := 0 to 200 do
    begin
      writeln('');
    end;
  end;

  function TMyApplication.EncloseOption(Option: string): string;
  var
    OptionEncloser: string;
  begin
    OptionEncloser := 'invalid, fix the code';
    {$IFDEF UNIX}
    OptionEncloser := ''''; //single quotes around arguments
    {$ENDIF}
    {$IFDEF WINDOWS}
    OptionEncloser := '"'; //double quotes around arguments
    {$ENDIF}
    if (AnsiPos(' ', Option) > 0) or (Option = '') then
    begin
      Result := OptionEncloser + Option + OptionEncloser;
    end
    else
    begin
      Result := Option;
    end;
  end;

  procedure TMyApplication.ShowInfoAsOptions;
  // Shows chosen options as command line arguments
  var
    HostName: string;
  begin
    writeln('Options chosen:');
    Write('pasql '); //program name
    Write('--type=');
    case FDatabaseType of
      dtFirebird: Write('Firebird ');
      dtMSSQL: Write('SQLSERVER ');
      dtMySQL51: Write('MySQL ');
      dtODBC: Write('ODBC ');
      dtOracle: Write('Oracle ');
      dtPostgreSQL: Write('PostgreSQL ');
      dtSQLite: Write('SQLite ');
      dtSybase: Write('Sybase ');
      else
        raise Exception.Create('Unknown database type, please fix this code');
    end;

    if FEmbedded = bTrue then
      Write('--embedded ');

    if FServer <> '' then
    begin
      HostName := FServer;
      if FUseInstance = BTrue then
      begin
        HostName := HostName + '\' + FInstance;
      end
      else
      begin
        if FPort <> 0 then
        begin
          //assuming you can't specify a port and an instance together
          HostName := HostName + ':' + EncloseOption(IntToStr(FPort));
        end;
      end;
      Write('--hostname=' + EncloseOption(HostName) + ' ');
    end;

    if FDatabase <> '' then
    begin
      Write('--database=' + EncloseOption(FDatabase) + ' ');
    end;
    if FTrustedConnection = BTrue then
    begin
      Write('--trusted ');
    end
    else
    begin
      //No trusted FConnection
      Write('--username=' + EncloseOption(FUsername) + ' --password=' + EncloseOption(FPassword) + ' ');
    end;
    if FCharSet <> '' then
    begin
      Write('--characterset=' + EncloseOption(FCharset) + ' ');
    end;
    writeln('');//end of line
  end;

  procedure TMyApplication.ShowUserInfo;
  var
    TDSVEREnvironment: string;
  begin
    writeln('Current connection settings:');
    Write('Server type: ');
    writeln(FDatabaseType);
    writeln('Server: ' + FServer);
    if FUseInstance = BTrue then
    begin
      writeln('Instance: ' + FInstance);
    end
    else
    begin
      writeln('Port: ' + IntToStr(FPort));
    end;
    if FDatabase <> '' then
      writeln('Database: ' + FDatabase);
    if FTrustedConnection = BTrue then
    begin
      writeln('Authentication: trusted connection');
    end
    else
    begin
      writeln('Username: ' + FUsername);
      writeln('Password: ' + FPassword);
    end;

    //Help build parameter list for next use
    if Trim(ParamStr(1)) = '' then
    begin
      ShowInfoAsOptions;
    end;

    if FDatabaseType in [dtMSSQL, dtSybase] then
    begin
      if FWeChangedTDSVER = false then
      begin
        TDSVEREnvironment := GetEnvironmentVariable('TDSVER');
        if TDSVEREnvironment <> '' then
        begin
          writeln('Note: found TDSVER environment variable set to: ' + TDSVEREnvironment);
          writeln('This might influence connectivity with the server.');
        end;
      end;
    end;
  end;

  procedure TMyApplication.GetLogEvent(Sender: TSQLConnection; EventType: TDBEventType; const Msg: string);
  // Gets log events from connection and stores them for us.
  var
    Source: string;
  begin
    // Nicely right aligned.
    // Set source to empty string to avoid logging it.
    case EventType of
      detCustom: Source := 'Custom:  ';
      detPrepare: Source := 'Prepare: ';
      detExecute: Source := 'Execute: ';
      detFetch: Source := ''; //this will return empty statements anway. A bit useless to do
      detCommit: Source := 'Commit:  ';
      detRollBack: Source := 'Rollback:';
      else
        Source := 'Unknown event. Please fix pasql code.';
    end;
    if Source <> '' then
      FConnectionLog.Add(Source + ' ' + Msg);
  end;

  procedure TMyApplication.Connect;
  begin
    //TSQLConnection
    case FDatabaseType of
      dtFirebird:
      begin
        {$IF FPC_FULLVERSION<20602}
        // Old FPC versions require explicit direction to use embedded library.
        // An empty hostname is not enough.
        // Don't know if this still applies for FPC 2.6 but it won't hurt.
        if FEmbedded = BTrue then
          UseEmbeddedFirebird := true;
        {$ENDIF}
        FConnection := TIBConnection.Create(nil);
      end;
      {$IF FPC_FULLVERSION>=20601}
      // not present in 2.6.0
      dtMSSQL: FConnection := TMSSQLConnection.Create(nil);
      {$ENDIF}
      dtMySQL51: FConnection := TMySQL51Connection.Create(nil);
      dtODBC: FConnection := TODBCConnection.Create(nil);
      {$IFNDEF WIN64}
      dtOracle: FConnection := TOracleConnection.Create(nil);
      {$ENDIF}
      dtPostgreSQL: FConnection := TPQConnection.Create(nil);
      dtSQLite: FConnection := TSQLite3Connection.Create(nil);
      {$IF FPC_FULLVERSION>=20601}
      // not present in 2.6.0
      dtSybase: FConnection := TSybaseConnection.Create(nil);
      {$ENDIF}
      else
        raise Exception.Create('Unknown database type, please fix this code');
    end;

    if FCharset = '' then
      if FDatabaseType=dtMySQL51 then
        FConnection.CharSet := 'utf8' //default
      else
        FConnection.CharSet := 'UTF-8' //default
    else
      FConnection.CharSet := FCharset;
    FConnection.DatabaseName := FDatabase;
    FConnection.HostName := FServer;
    FConnection.UserName := FUsername;
    FConnection.Password := FPassword;
    case FDatabaseType of
      dtFirebird:
      begin
        TIBConnection(FConnection).Dialect := 3;
        if FEmbedded = btrue then
          FConnection.HostName := ''
        else
          FConnection.HostName := FServer + '/' + IntToStr(FPort);
      end;
      dtMSSQL:
      begin
        FConnection.Params.Add('TEXTSIZE=2147483647'); //Large (>16 MB) blob support
        //Override hostname and username/password if necessary
        if FUseInstance = Btrue then
        begin
          FConnection.HostName := FServer + '\' + FInstance;
        end
        else
        begin
          FConnection.HostName := FServer + ':' + IntToStr(FPort);
        end;
        if FTrustedConnection = Btrue then
        begin
          FConnection.Username := '';
          FConnection.Password := '';
        end;
      end;
      dtMySQL51:
      begin
        // nothing special; todo: perhaps utf8 charset?
      end;
      dtODBC:
      begin
        // Because of mapping, only allow connection strings (in the server part) and/or DSN names in the database part
        //todo: driver?!?!
        FConnection.DatabaseName := FDatabase;
        // DSN ... no, DatabaseName seems to map to connection string?
        FConnection.HostName := '';
        FConnection.Params.Text := FServer;
        //Parameters - to do: check split out as strings? Or as ; separated
      end;
      dtOracle, dtPostgreSQL, dtSQLite:
      begin
        //nothing special for now
      end;
      dtSybase:
      begin
        FConnection.HostName := FServer + ':' + IntToStr(FPort);
      end;
      else
        raise Exception.Create('Unknown database type, please fix this code');
    end;

    CreateDBFile;

    // Decide which events to log (all of them)...
    FConnection.LogEvents := [detCustom, detPrepare, detExecute, detFetch, detCommit, detRollBack];
    // ... then let the connection pass on the events to our function:
    FConnection.OnLog := @Self.GetLogEvent;
    try
      FConnection.Connected := true;
    except
      on E: Exception do
      begin
        writeln('Error connecting to server: ' + E.ClassName + '/' + E.Message);
        halt(32); //Exit code 32: FConnection error
      end;
    end;

    FTransaction := TSQLTransaction.Create(nil);
    FConnection.Transaction := FTransaction;

    FQuery := TSQLQuery.Create(nil);
    FQuery.Database := FConnection;
    FQuery.ParseSQL := true; // we want to parse statementtype & parameters

    case FDatabaseType of
      dtFirebird:
      begin
        // Nothing special
      end;
      dtMSSQL:
      begin
        FQuery.PacketRecords := -1; //To fetch all pending rows; See mssqlconn readme
        FTransaction.StartTransaction;
        FConnection.ExecuteDirect('SET CONCAT_NULL_YIELDS_NULL ON');
        FTransaction.Commit;
      end;
      //todo: look into transaction management
      dtMySQL51, dtODBC, dtOracle, dtPostgreSQL, dtSQLite:
      begin
        // Nothing special
      end;
      dtSybase:
      begin
        FQuery.PacketRecords := -1; //To fetch all pending rows; See mssqlconn readme
      end;
      else
        raise Exception.Create('Connect: Unknown database type, please fix this code');
    end;
  end;

  procedure TMyApplication.CreateDBFile;
  var
    DBConn: TIBConnection;
    DBTran: TSQLTransaction;
  begin
    // Create embedded database if necessary
    // dtSQLite will create the db automatically; dtFirebird won't:
    if (FEmbedded = btrue) and
      (FileExists(FDatabase) = false) and
      (FDatabaseType = dtFirebird) then
    begin
      DBConn := TIBConnection.Create(nil);
      DBTran := TSQLTransaction.Create(nil);
      try
        DBConn.Transaction := DBTran;
        // Copy over relevant settings from our connection object:
        DBConn.Dialect := TIBConnection(FConnection).Dialect;
        DBConn.DatabaseName := FConnection.DatabaseName;
        DBConn.UserName := FConnection.UserName;
        DBConn.Password := FConnection.Password;
        DBConn.Params.AddStrings(FConnection.Params);
        // Page size 16384 so we have maximum space for indexes
        DBConn.Params.Add('PAGE_SIZE=16384');
        DBConn.CreateDB;
      finally
        DBTran.Free;
        DBConn.Free;
      end;
    end;
  end;

  procedure TMyApplication.Disconnect;
  begin
    FTransaction.Active := false;
    FQuery.Free;
    FConnection.Close;
    FConnection.Free;
  end;

  function TMyApplication.RunSQL(SQL: string; BriefOutput: boolean): boolean;
    // Sends SQL to database.
    // If the SQL is not an execute only command, it
    // returns data to the screen.
    // Returns true if succesful, false if not
  const
    // Used for both dtSybase and MS SQL Server:
    SybaseChangeDatabase = 'USE';
  var
    Counter: integer;
    ExecuteOnly: boolean;
    UserParam: TParam;
    ParamUsed: boolean;
    ParamValue: string;
    i:integer;
  begin
    Result := false; //fail by default
    ExecuteOnly := false;
    FQuery.Close;
    try
      FQuery.SQL.Text := SQL;
      if BriefOutput = false then
        writeln('==============================================================');
      // Determine in advance if something is execute only
      case FDatabaseType of
        dtMSSQL, dtSybase:
        begin
          if AnsiPos(SybaseChangeDatabase + ' ', UpperCase(Trim(SQL))) = 1 then
            ExecuteOnly := true;
        end;
        dtFirebird, dtMySQL51, dtODBC, dtOracle, dtPostgreSQL, dtSQLite:
        begin
          //No database specific stuff
        end;
        else
          raise Exception.Create('RunSQL: Unknown database type, please fix the code');
      end;
      FQuery.Prepare;
      // User specified parameters (e.g. SELECT :MYPARAM FROM DUAL)
      ParamUsed:=false;
      if FQuery.Params.Count>0 then
      begin
        ParamUsed:=true;
        writeln('PAR> Parameters found in the query:');
        for i:=0 to FQuery.Params.Count-1 do
        begin
          UserParam:=FQuery.Params[i];
          writeln('PAR> '+UserParam.DisplayName);
          writeln('PAR> Please enter value:');
          readln(ParamValue);
          UserParam.AsString:=ParamValue;
          writeln('debug: param set to:');
          writeln(UserParam.AsString);
          writeln('');
        end;
      end;
      {$IF FPC_FULLVERSION >= 20701}
      // Let's see if the query itself thinks it's executable:
      // StatementType is not supported in 2.6.x
      if ExecuteOnly = false then
        ExecuteOnly := not(FQuery.StatementType = stSelect);
      {$ENDIF}
      try
        if ExecuteOnly = false then
          FQuery.Open;
      except
        on Z: Exception do
        begin
          // Assume it's an executable query.
          // A query containing a syntax error etc will be wrongly detected as executable
          // todo: fix this based on detailed error message retrieved from db!?!?
          ExecuteOnly := true;
        end;
      end;

      if ExecuteOnly = false then
      begin
        if BriefOutput = false then
        begin
          // Column headers
          for Counter := 0 to FQuery.FieldCount - 1 do
          begin
            if Counter = FQuery.FieldCount - 1 then
            begin
              // Last column, line ending
              writeln(FQuery.Fields[Counter].FieldName);
            end
            else
            begin
              Write(FQuery.Fields[Counter].FieldName + #9);
            end;
          end;
          writeln('==============================================================');
        end;

        while not FQuery.EOF do
        begin
          // Data
          for Counter := 0 to FQuery.FieldCount - 1 do
          begin
            if Counter = FQuery.FieldCount - 1 then
            begin
              // Last column, line ending
              writeln(FQuery.Fields[Counter].AsString);
            end
            else
            begin
              Write(FQuery.Fields[Counter].AsString + #9);
            end;
          end;
          FQuery.Next;
        end;
      end
      else
      begin
        // Executeonly
        if BriefOutput = false then
        begin
          writeln('Going to execute: ');
          writeln(SQL);
        end;
        FQuery.ExecSQL;
        if BriefOutput = false then
          writeln('Done executing.');
      end;
      Result := true;
      //todo: offer to run again with other values for parameters
    except
      {$IF FPC_FULLVERSION>=20601}
      // not present in 2.6.0
      on A: EMSSQLDatabaseError do
      begin
        writeln('Database error: ' + A.Message,
          '. Server Error code: ', A.DBErrorCode);
        writeln('SQL statement was: ' + SQL);
      end;
      {$ENDIF}
      on B: EIBDatabaseError do
      begin
        writeln('Database error   : ');
        writeln(B.Message);
        writeln('GDS error code   : ', B.GDSErrorCode);
        {$IF FPC_FULLVERSION>=20701}
        writeln('SQLState         : ', B.SQLState);
        {$ENDIF}
        writeln('SQL statement was: ' + SQL);
      end;
      on C: EODBCException do
      begin
        writeln('Database error: ' + C.Message);
        writeln('SQL statement was: ' + SQL);
      end;
      {$IFNDEF WIN64}
      // Oracle connector not available on Windows x64
      on D: EOraDatabaseError do
      begin
        writeln('Database error: ' + D.Message);
        writeln('ORA error code: ', D.ORAErrorCode);
        writeln('SQL statement was: ' + SQL);
      end;
      {$ENDIF}
      {$IF FPC_FULLVERSION>=20701}
      // not present in 2.6.0, probably not in 2.6.1
      // Patch with support for more detailed dtPostgreSQL error reporting
      //http://bugs.freepascal.org/view.php?id=22336
      on E: EPQDatabaseError do
      begin
        writeln('Database error: ' + E.Message);
        writeln('Severity:       ' + E.Severity);
        writeln('SQLSTATE:       ' + E.SQLSTATE);
        writeln('Primary mesage: ' + E.MESSAGE_PRIMARY);
        writeln('Detailed message:   ' + E.MESSAGE_DETAIL);
        writeln('Message hint:       ' + E.MESSAGE_HINT);
        writeln('Statement position: ' + E.STATEMENT_POSITION);
        writeln('SQL statement was:  ' + SQL);
      end;
      {$ENDIF}
      {$IF FPC_FULLVERSION<20701}
      // No specific error code descendants (e.g. SQLite3)...
      on Y: EDatabaseError do
      begin
        writeln('Database error:    ' + Y.Message);
        writeln('SQL statement was: ' + SQL);
      end;
      {$ELSE}
      // No specific error code descendants (e.g. SQLite3)...
      on Y: ESQLDatabaseError do
      begin
        writeln('Database error:    ' + Y.Message);
        writeln('Error code:        ' + inttostr(Y.ErrorCode));
        writeln('SQLState:          ' + Y.SQLState);
        writeln('SQL statement was: ' + SQL);
      end;
      {$ENDIF}
      on Z: Exception do
      begin
        writeln('Error. Technical details: ', Z.ClassName, '/', Z.message);
        writeln('SQL statement was: ' + SQL);
      end;
    end;
    FQuery.Close;
  end;

  procedure TMyApplication.SQLConsole;
  // Offers small console functionality.
  // Wiodows Vista+ seems to offer up/down cursor history facility... nice.
  const
    MyWordDelims = StdWordDelims+[#10,#13]; //also break at end of line
  var
    Response: string;
    History: TStringList;
    Counter: integer;
    SQL: TStringList; //sql user wants to execute; possibly multiple lines
    SQLTrimUpper: string; //uppercase and trimmed sql.txt
    FirstLine: boolean;
    SaveHistory: boolean; //does user want to save command history to file?
    StatementSeparator: boolean;
  begin
    History := TStringList.Create;
    SaveHistory := false;
    SQL := TStringList.Create;
    try
      FirstLine := true;
      // Endless loop that only breaks when user tells it to:
      repeat
        begin
          if (FirstLine = true) then
          begin
            Write('SQL  >');
          end
          else
          begin
            // User did not finish statement, so show that:
            Write('SQL+ >');
          end;
          readln(Response);
          case UpperCase(Trim(Response)) of
            'EXIT','QUIT':
            begin
              break;
            end;
            'EXITSAVE', 'QUITSAVE':
            begin
              SaveHistory:=true;
              break;
            end;
          end;
          // Support both dtFirebird & dtMSSQL style statement separators
          StatementSeparator := false;
          if UpperCase(Trim(Response)) = SybaseStatementSeparator then
            StatementSeparator := true;
          if UpperCase(Trim(Response)) = FirebirdStatementSeparator then
            StatementSeparator := true;
          if UpperCase(Trim(Response)) = FirebirdStatementSeparator + ';' then
            StatementSeparator := true;
          if StatementSeparator then
          begin
            // Preprocess some special values
            SQLTrimUpper:=UpCase(Trim(SQL.Text));
            // Show tables is built into mysql, so use that
            if (FDatabaseType<>dtMySQL51) and
              (wordcount(SQLTrimUpper,MyWordDelims)=2) and
              (ExtractWord(1,SQLTrimUpper,MyWordDelims)='SHOW') and
              (ExtractWord(2,SQLTrimUpper,MyWordDelims)='TABLES') then
            begin
              if PrintTables then
                History.Add(SQL.Text);
              // Wipe slate clean
              SQL := TStringList.Create;
              FirstLine := true;
            end
            else
            // Show fields for a table:
            // SHOW TABLE x
            // DESCRIBE TABLE x
            // DESC TABLE x
            if wordcount(SQLTrimUpper,MyWordDelims)=3 then
            begin
              if ((ExtractWord(1,SQLTrimUpper,MyWordDelims)='DESC') or
                (ExtractWord(1,SQLTrimUpper,MyWordDelims)='DESCRIBE') or
                (ExtractWord(1,SQLTrimUpper,MyWordDelims)='SHOW')) and
                (ExtractWord(2,SQLTrimUpper,MyWordDelims)='TABLE') then
              begin
                // Use user-specified casing (upper/lower) for the table name:
                if PrintFields(ExtractWord(3,Trim(SQL.Text),StdWordDelims)) then
                  History.Add(SQL.Text);
                // Wipe slate clean
                SQL := TStringList.Create;
                FirstLine := true;
              end;
            end
            else
            begin
              // Actually execute the statement
              if RunSQL(SQL.Text, false) = true then
                History.Add(SQL.Text);
              // Wipe slate clean
              SQL := TStringList.Create;
              FirstLine := true;
            end;
          end
          else
          begin
            SQL.Add(Response);
            FirstLine := false;
          end;
        end;
      until 0 = 1;
      if SaveHistory then
      try
        begin
          History.SaveToFile('history.txt');
          writeln('Saved history as history.txt');
        end;
      except
        on E: Exception do
        begin
          writeln('Error saving history: '+E.Message);
        end;
      end;
      // Print out history:
      writeln('==============================================================');
      writeln('Command history:');
      for Counter := 0 to History.Count - 1 do
      begin
        writeln(History[Counter]);
      end;
      if SaveHistory then
      try
        begin
          FConnectionLog.SaveToFile('log.txt');
          writeln('Saved SQLDB log as log.txt');
        end;
      except
        on E: Exception do
        begin
          writeln('Error saving log: '+E.Message);
        end;
      end;
      writeln('SQLDB log (note: queries may be prepared+executed 2x due to pasql design):');
      for Counter := 0 to FConnectionLog.Count - 1 do
      begin
        writeln(FConnectionLog[Counter]);
        writeln(''); //some spacing will help.
      end;
    finally
      History.Free;
      SQL.Free;
    end;
  end;

  procedure TMyApplication.RunScript;
  // Tries to run script
  var
    Scripter: TSQLScript;
    ScriptText: TStringList;
  begin
    ScriptText := TStringList.Create;
    try
      ScriptText.LoadFromFile(FScriptFile);
      // Use FPC functionality
      {$IF FPC_FULLVERSION<20701}
      // New functionality not yet in 2.6.4
      {$Warning FPC<2.7.1: SQL script support is unreliable}
      writeln('Program compiled with FPC < 2.7.1. ');
      writeln('SQL script support for complex scripts can be unreliable.');
      {$ENDIF}
      Scripter := TSQLScript.Create(nil);
      try
        Scripter.DataBase := FConnection;
        Scripter.Transaction := FConnection.Transaction;
        if FDatabaseType=dtFirebird then
        begin
          //allow SET TERM commands for stored proc definition etc
          Scripter.UseSetTerm:=true;
          // ... and script may will have explicit COMMITs after DDL
          Scripter.UseCommit:=true;
        end;
        Scripter.Script := ScriptText;
        Scripter.ExecuteScript;
      finally
        Scripter.Free;
      end;
    finally
      ScriptText.Free;
    end;
  end;

  function TMyApplication.PrintFields(Table: string): boolean;
  var
    ResultList: TStringList;
  begin
    result:=false;
    ResultList:=TStringList.Create;
    try
      FConnection.GetFieldNames(Table,ResultList);
      if ResultList.Count=0 then
      begin
        writeln('Database error: table '+Table+' does not exist or ');
        writeln('error retrieving field data.');
      end
      else
        writeln(ResultList.Text);
      result:=true;
    finally
      ResultList.Free;
    end;
  end;

  function TMyApplication.PrintTables: boolean;
  var
    TableList: TStringList;
  begin
    result:=false;
    TableList:=TStringList.Create;
    try
      FConnection.GetTableNames(TableList,false);
      writeln(TableList.Text);
      result:=true;
    finally
      TableList.Free;
    end;
  end;

  procedure TMyApplication.DoRun;
  var
    ErrorMsg: string;
  begin
    FDatabase := '';
    FDatabaseType := dtUndefinedDatabaseType;
    FEmbedded := BNull; //undefined
    FInstance := '';
    FPassword := '';
    FPort := 0;
    FServer := '';
    FTrustedConnection := BNull; //undefined
    FUseInstance := BNull; //undefined
    FUsername := '';
    FWeChangedTDSVER := false;
    FConnectionLog := TStringList.Create;
    try
      CommandLineOptions;
      GetUserInfo; //ask user for FConnection settings and...
      ShowUserInfo; //...repeat it back to him
      { Now try a connect to the master FDatabase, and run a simple FQuery }
      Connect;
      writeln('Connection complete.');

      {$IF FPC_FULLVERSION>=20701}
      writeln('Server type: ');
      writeln(FConnection.GetConnectionInfo(citServerType));
      writeln('Server identification: ');
      writeln(FConnection.GetConnectionInfo(citServerVersionString));
      writeln('Pseudo-numerical version:');
      writeln(FConnection.GetConnectionInfo(citServerVersion));
      writeln('Client name:');
      writeln(FConnection.GetConnectionInfo(citClientName));
      writeln('Client version:');
      writeln(FConnection.GetConnectionInfo(citClientVersion));
      if FDatabaseType = dtFirebird then
      begin
        writeln('ODS major version: ' + IntToStr(TIBConnection(FConnection).ODSMajorVersion));
        writeln('Dialect: ' + IntToStr(TIBConnection(FConnection).Dialect));
      end;
      {$ELSE}
      writeln('Server version: ');
      case FDatabaseType of
        dtFirebird: RunSQL('SELECT rdb$get_context(''SYSTEM'', ''ENGINE_VERSION'') from rdb$database ',true); //FB 2.1+
        dtMSSQL: RunSQL('select @@version', true);
        dtPostgreSQL: RunSQL('select version();', true);
        dtSybase: RunSQL('select @@version', true);
        else
          writeln('Don''t know how to get version for this database server. Sorry.');
          //raise Exception.Create('Unknown database type, please fix this code');
      end;
      {$ENDIF}

      if FScriptFile <> '' then
        RunScript;

      writeln('==============================================================');
      writeln('Starting SQL console.');
      writeln('Enter your SQL; run it by writing ');
      writeln(SybaseStatementSeparator);
      writeln('or');
      writeln(FirebirdStatementSeparator);
      writeln('or');
      writeln(FirebirdStatementSeparator + ';');
      writeln('on a single line.');
      writeln('Enter EXIT and enter to quit or EXITSAVE to save all your statements to file and quit.');
      SQLConsole; //Breaks on 'exit', 'quit', 'exitsave', 'quitsave'
      writeln('==============================================================');
      writeln('Disconnecting.');
      Disconnect;
    finally
      FConnectionLog.Free;
    end;

    //Clean up:
    if FWeChangedTDSVER = true then
    begin
      try
        {$IFDEF WINDOWS}
        // Changing environment vars on running process only works on Windows
        SetEnvironmentVariable('TDSVER', PChar(FOriginalTDSVER));
        {$ENDIF}
      except
        writeln('Could not reset TDSVER environment variable back to:');
        writeln(FOriginalTDSVER);
        writeln('Sorry.');
      end;
    end;

    // stop program loop
    Terminate;
  end;

var
  Application: TMyApplication;
begin
  Application := TMyApplication.Create(nil);
  Application.Title := 'pasql';
  Application.Run;
  Application.Free;
end.
